diff --git a/Makefile b/Makefile
index 3be9d8c..4a4503e 100644
--- a/Makefile
+++ b/Makefile
@@ -1,6 +1,6 @@
 
-CC   := gcc
-CXX  := g++
+CC   := g++ -w -std=c++17
+CXX  := g++ -w -std=c++17
 LD   := $(CXX)
 
 MSG_PREFIX ?=
@@ -47,7 +47,7 @@ ARCHFLAGS := $(ARCHFLAGS)
 
 #OPTFLAGS  ?= -g -O
 #OPTFLAGS  ?= -g -O0
-OPTFLAGS  ?= -O3
+OPTFLAGS  ?= -O2 -g
 
 CFLAGS    += -Wall -Wno-parentheses -Wno-unused-function -Wno-write-strings -Wno-sign-compare $(ARCHFLAGS)
 ifneq ($(findstring arm,$(shell uname -m)),)
@@ -190,7 +190,7 @@ tags:
 
 $(PROG): $(OBJ)
 	@echo "$(MSG_PREFIX)\`\` Building binary:" $(notdir $@)
-	$(VERBOSE)$(LD) -o $@ $^ $(LIBS)
+	$(LD) -o $@ $^ $(LIBS) -lgmpxx -lgmp
 
 lib$(PROG).a: $(LIBOBJ)
 	@echo "$(MSG_PREFIX)\`\` Linking:" $(notdir $@)
diff --git a/src/base/abci/abcNtbdd.c b/src/base/abci/abcNtbdd.c
index c3bc5c7..b5bb57b 100644
--- a/src/base/abci/abcNtbdd.c
+++ b/src/base/abci/abcNtbdd.c
@@ -34,11 +34,13 @@ ABC_NAMESPACE_IMPL_START
 
 #ifdef ABC_USE_CUDD
 
+extern "C" {
 static void        Abc_NtkBddToMuxesPerform( Abc_Ntk_t * pNtk, Abc_Ntk_t * pNtkNew );
 static Abc_Obj_t * Abc_NodeBddToMuxes( Abc_Obj_t * pNodeOld, Abc_Ntk_t * pNtkNew );
 static Abc_Obj_t * Abc_NodeBddToMuxes_rec( DdManager * dd, DdNode * bFunc, Abc_Ntk_t * pNtkNew, st__table * tBdd2Node );
 //static DdNode *    Abc_NodeGlobalBdds_rec( DdManager * dd, Abc_Obj_t * pNode, int nBddSizeMax, int fDropInternal, ProgressBar * pProgress, int * pCounter, int fVerbose );
 DdNode *    Abc_NodeGlobalBdds_rec( DdManager * dd, Abc_Obj_t * pNode, int nBddSizeMax, int fDropInternal, ProgressBar * pProgress, int * pCounter, int fVerbose );
+}
 
 ////////////////////////////////////////////////////////////////////////
 ///                     FUNCTION DEFINITIONS                         ///
diff --git a/src/base/io/ioAbc.h b/src/base/io/ioAbc.h
index 63ba301..d41f6ef 100644
--- a/src/base/io/ioAbc.h
+++ b/src/base/io/ioAbc.h
@@ -137,7 +137,7 @@ extern int                Io_WriteSmv( Abc_Ntk_t * pNtk, char * FileName );
 /*=== abcWriteVerilog.c =======================================================*/
 extern void               Io_WriteVerilog( Abc_Ntk_t * pNtk, char * FileName );
 /*=== abcUtil.c ===============================================================*/
-extern Io_FileType_t      Io_ReadFileType( char * pFileName );
+extern Io_FileType_t      Io_ReadFileType( const char * pFileName );
 extern Io_FileType_t      Io_ReadLibType( char * pFileName );
 extern Abc_Ntk_t *        Io_ReadNetlist( char * pFileName, Io_FileType_t FileType, int fCheck );
 extern Abc_Ntk_t *        Io_Read( char * pFileName, Io_FileType_t FileType, int fCheck, int fBarBufs );
diff --git a/src/base/io/ioUtil.c b/src/base/io/ioUtil.c
index 8950306..3638c81 100644
--- a/src/base/io/ioUtil.c
+++ b/src/base/io/ioUtil.c
@@ -43,9 +43,10 @@ ABC_NAMESPACE_IMPL_START
   SeeAlso     []
 
 ***********************************************************************/
-Io_FileType_t Io_ReadFileType( char * pFileName )
+extern "C" {
+Io_FileType_t Io_ReadFileType( const char * pFileName )
 {
-    char * pExt;
+    const char * pExt;
     if ( pFileName == NULL )
         return IO_FILE_NONE;
     pExt = Extra_FileNameExtension( pFileName );
@@ -83,6 +84,7 @@ Io_FileType_t Io_ReadFileType( char * pFileName )
         return IO_FILE_VERILOG;
     return IO_FILE_UNKNOWN;
 }
+}
 
 /**Function*************************************************************
 
diff --git a/src/base/main/mainInit.c b/src/base/main/mainInit.c
index 34228cc..ad6b06f 100644
--- a/src/base/main/mainInit.c
+++ b/src/base/main/mainInit.c
@@ -61,8 +61,10 @@ extern void Abc2_Init( Abc_Frame_t * pAbc );
 extern void Abc2_End ( Abc_Frame_t * pAbc );
 extern void Abc85_Init( Abc_Frame_t * pAbc );
 extern void Abc85_End( Abc_Frame_t * pAbc );
+extern "C" {
 extern void Ssat_Init( Abc_Frame_t * pAbc );
 extern void Ssat_End( Abc_Frame_t * pAbc );
+}
 extern void Pb_Init( Abc_Frame_t * pAbc );
 extern void Pb_End( Abc_Frame_t * pAbc );
 
diff --git a/src/bdd/cudd/Makefile b/src/bdd/cudd/Makefile
index d769547..0301339 100644
--- a/src/bdd/cudd/Makefile
+++ b/src/bdd/cudd/Makefile
@@ -4,7 +4,7 @@
 #---------------------------
 .SUFFIXES: .o .c .u
 
-CC	= gcc
+CC	= g++ -std=c++17
 RANLIB	= ranlib
 PURE	=
 # Define EXE as .exe for MS-DOS and derivatives.
diff --git a/src/bdd/cudd/cudd.h b/src/bdd/cudd/cudd.h
index 21ff39e..5318cc9 100644
--- a/src/bdd/cudd/cudd.h
+++ b/src/bdd/cudd/cudd.h
@@ -62,6 +62,8 @@
 /* Nested includes                                                           */
 /*---------------------------------------------------------------------------*/
 
+#include <gmpxx.h>
+#include <optional>
 #include "bdd/mtr/mtr.h"
 #include "bdd/epd/epd.h"
 
@@ -274,6 +276,18 @@ typedef struct DdChildren {
     struct DdNode *E;
 } DdChildren;
 
+struct Indirection {
+    // NZ : add members to record
+    // > max satisfying probability (pMax)
+    // > min satisfying probability (pMin)
+    // > max choice (cMax)
+    // > min choice (cMin)
+    mpq_class pMax;
+    mpq_class pMin;
+    int   cMax;
+    int   cMin;
+};
+
 /* The DdNode structure is the only one exported out of the package */
 struct DdNode {
     DdHalfWord index;
@@ -285,17 +299,10 @@ struct DdNode {
     } type;
     ABC_INT64_T Id;
 
-    // NZ : add members to record
-    // > max satisfying probability (pMax)
-    // > min satisfying probability (pMin)
-    // > max choice (cMax)
-    // > min choice (cMin)
-    float pMax;
-    float pMin;
-    int   cMax;
-    int   cMin;
+    std::optional<struct Indirection*> i;
 };
 
+
 #ifdef __osf__
 #pragma pointer_size restore
 #endif
diff --git a/src/bdd/cudd/cuddInt.h b/src/bdd/cudd/cuddInt.h
index 2ccf86a..d3bbc62 100644
--- a/src/bdd/cudd/cuddInt.h
+++ b/src/bdd/cudd/cuddInt.h
@@ -546,6 +546,7 @@ typedef struct DdLevelQueue {
 ******************************************************************************/
 #define cuddDeallocNode(unique,node) \
     (node)->next = (unique)->nextFree; \
+    if ((node)->i.has_value()) { delete (node)->i.value() ; (node)->i = std::nullopt; }; \
     (unique)->nextFree = node;
 
 /**Macro***********************************************************************
@@ -563,6 +564,7 @@ typedef struct DdLevelQueue {
 ******************************************************************************/
 #define cuddDeallocMove(unique,node) \
     ((DdNode *)(node))->ref = 0; \
+    if (((DdNode *)(node))->i.has_value()) { delete ((DdNode *)(node))->i.value() ; ((DdNode *)(node))->i = std::nullopt; }; \
     ((DdNode *)(node))->next = (unique)->nextFree; \
     (unique)->nextFree = (DdNode *)(node);
 
@@ -601,7 +603,7 @@ typedef struct DdLevelQueue {
   SeeAlso      [Cudd_Deref]
 
 ******************************************************************************/
-#define cuddDeref(n) cuddSatDec(Cudd_Regular(n)->ref)
+#define cuddDeref(n) Cudd_Deref(n)
 
 
 /**Macro***********************************************************************
diff --git a/src/bdd/cudd/cuddRef.c b/src/bdd/cudd/cuddRef.c
index f3e643e..31d56af 100644
--- a/src/bdd/cudd/cuddRef.c
+++ b/src/bdd/cudd/cuddRef.c
@@ -174,6 +174,10 @@ Cudd_RecursiveDeref(
 
         if (N->ref == 1) {
             N->ref = 0;
+            if (N->i.has_value()) {
+                delete N->i.value();
+                N->i = std::nullopt;
+            }
             table->dead++;
 #ifdef DD_STATS
             table->nodesDropped++;
@@ -237,6 +241,10 @@ Cudd_IterDerefBdd(
 
         if (N->ref == 1) {
             N->ref = 0;
+            if (N->i.has_value()) {
+                delete N->i.value();
+                N->i = std::nullopt;
+            }
             table->dead++;
 #ifdef DD_STATS
             table->nodesDropped++;
@@ -440,6 +448,12 @@ Cudd_Deref(
 {
     node = Cudd_Regular(node);
     cuddSatDec(node->ref);
+    if (node->ref == 0) {
+        if ((node)->i.has_value()) {
+            delete (node)->i.value();
+            node->i = std::nullopt;
+        }
+    }
 
 } /* end of Cudd_Deref */
 
diff --git a/src/bdd/cudd/cuddReorder.c b/src/bdd/cudd/cuddReorder.c
index 662d32c..7f72e81 100644
--- a/src/bdd/cudd/cuddReorder.c
+++ b/src/bdd/cudd/cuddReorder.c
@@ -480,6 +480,10 @@ cuddDynamicAllocNode(
 
     node = table->nextFree;
     table->nextFree = node->next;
+    // NZ: initialize pMax/pMin
+    //node->pMax = node->pMin = -1.0;
+    struct Indirection* foo = new struct Indirection;
+    node->i = std::optional<struct Indirection*>{foo};
     return (node);
 
 } /* end of cuddDynamicAllocNode */
diff --git a/src/bdd/cudd/cuddTable.c b/src/bdd/cudd/cuddTable.c
index e108a2a..a5678b6 100644
--- a/src/bdd/cudd/cuddTable.c
+++ b/src/bdd/cudd/cuddTable.c
@@ -332,6 +332,8 @@ cuddAllocNode(
     node->Id = (unique->allocated<<4);
     // NZ: initialize pMax/pMin
     //node->pMax = node->pMin = -1.0;
+    struct Indirection* foo = new struct Indirection;
+    node->i = std::optional<struct Indirection*>{foo};
     return(node);
 
 } /* end of cuddAllocNode */
diff --git a/src/extRegression/catch.hpp b/src/extRegression/catch.hpp
index 89ed9a4..bccc42c 100644
--- a/src/extRegression/catch.hpp
+++ b/src/extRegression/catch.hpp
@@ -12,6 +12,7 @@
 #define TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
 // start catch.hpp
 
+#include <gmpxx.h>
 
 #define CATCH_VERSION_MAJOR 2
 #define CATCH_VERSION_MINOR 13
diff --git a/src/extRegression/module.make b/src/extRegression/module.make
index 9aaa531..96d0622 100644
--- a/src/extRegression/module.make
+++ b/src/extRegression/module.make
@@ -3,6 +3,6 @@
 test: all
 	./$(PROG) -c "regression-test"
 
-CXXFLAGS += -std=c++11
+CXXFLAGS += -std=c++17
 SRC +=	src/extRegression/regression.cc
 
diff --git a/src/map/scl/sclCon.h b/src/map/scl/sclCon.h
index e64f3c7..e515bac 100644
--- a/src/map/scl/sclCon.h
+++ b/src/map/scl/sclCon.h
@@ -49,16 +49,6 @@ struct Scl_Con_t_
     Abc_Nam_t *    pNamO;       // output names
 };
 
-#define SCL_INPUT_CELL   "input_cell"
-#define SCL_INPUT_ARR    "input_arrival"
-#define SCL_INPUT_SLEW   "input_slew"
-#define SCL_INPUT_LOAD   "input_load"
-#define SCL_OUTPUT_REQ   "output_required"
-#define SCL_OUTPUT_LOAD  "output_load"
-
-#define SCL_DIRECTIVE(ITEM)     "."ITEM
-#define SCL_DEF_DIRECTIVE(ITEM) ".default_"ITEM
-
 #define SCL_NUM          1000
 #define SCL_INFINITY    (0x3FFFFFFF)
 
@@ -151,19 +141,19 @@ static inline int Scl_ConParse( Scl_Con_t * p, Abc_Nam_t * pNamI, Abc_Nam_t * pN
         }
         pToken3 = strtok( NULL, " \t\r\n" );
         if ( !strcmp(pToken, ".model") )                                p->pModelName  = Abc_UtilStrsav(pToken2);
-        else if ( !strcmp(pToken, SCL_DEF_DIRECTIVE(SCL_INPUT_CELL)) )  p->pInCellDef  = Abc_UtilStrsav(pToken2);
-        else if ( !strcmp(pToken, SCL_DEF_DIRECTIVE(SCL_INPUT_ARR))  )  p->tInArrDef   = Scl_Flt2Int(atof(pToken2));
-        else if ( !strcmp(pToken, SCL_DEF_DIRECTIVE(SCL_INPUT_SLEW)) )  p->tInSlewDef  = Scl_Flt2Int(atof(pToken2));
-        else if ( !strcmp(pToken, SCL_DEF_DIRECTIVE(SCL_INPUT_LOAD)) )  p->tInLoadDef  = Scl_Flt2Int(atof(pToken2));
-        else if ( !strcmp(pToken, SCL_DEF_DIRECTIVE(SCL_OUTPUT_REQ)) )  p->tOutReqDef  = Scl_Flt2Int(atof(pToken2));
-        else if ( !strcmp(pToken, SCL_DEF_DIRECTIVE(SCL_OUTPUT_LOAD)))  p->tOutLoadDef = Scl_Flt2Int(atof(pToken2));
+        else if ( !strcmp(pToken, ".default_input_cell") )  p->pInCellDef  = Abc_UtilStrsav(pToken2);
+        else if ( !strcmp(pToken, ".default_input_arrival")  )  p->tInArrDef   = Scl_Flt2Int(atof(pToken2));
+        else if ( !strcmp(pToken, ".default_input_slew") )  p->tInSlewDef  = Scl_Flt2Int(atof(pToken2));
+        else if ( !strcmp(pToken, ".default_input_load") )  p->tInLoadDef  = Scl_Flt2Int(atof(pToken2));
+        else if ( !strcmp(pToken, ".default_output_required") )  p->tOutReqDef  = Scl_Flt2Int(atof(pToken2));
+        else if ( !strcmp(pToken, ".default_output_load"))  p->tOutLoadDef = Scl_Flt2Int(atof(pToken2));
         else if ( pToken3 == NULL ) { printf( "Directive %s should be followed by two arguments.\n", pToken ); continue; }
-        else if ( !strcmp(pToken, SCL_DIRECTIVE(SCL_INPUT_CELL))  )     if ( (Num = Abc_NamStrFind(pNamI, pToken2)) > 0 )  Vec_PtrWriteEntry( &p->vInCells,  Num-1, Abc_UtilStrsav(pToken3) );    else printf( "Line %d: Cannot find input \"%s\".\n", nLines, pToken2 );
-        else if ( !strcmp(pToken, SCL_DIRECTIVE(SCL_INPUT_ARR))   )     if ( (Num = Abc_NamStrFind(pNamI, pToken2)) > 0 )  Vec_IntWriteEntry( &p->vInArrs,   Num-1, Scl_Flt2Int(atof(pToken3)) ); else printf( "Line %d: Cannot find input \"%s\".\n", nLines, pToken2 );
-        else if ( !strcmp(pToken, SCL_DIRECTIVE(SCL_INPUT_SLEW))  )     if ( (Num = Abc_NamStrFind(pNamI, pToken2)) > 0 )  Vec_IntWriteEntry( &p->vInSlews,  Num-1, Scl_Flt2Int(atof(pToken3)) ); else printf( "Line %d: Cannot find input \"%s\".\n", nLines, pToken2 );
-        else if ( !strcmp(pToken, SCL_DIRECTIVE(SCL_INPUT_LOAD))  )     if ( (Num = Abc_NamStrFind(pNamI, pToken2)) > 0 )  Vec_IntWriteEntry( &p->vInLoads,  Num-1, Scl_Flt2Int(atof(pToken3)) ); else printf( "Line %d: Cannot find input \"%s\".\n", nLines, pToken2 );
-        else if ( !strcmp(pToken, SCL_DIRECTIVE(SCL_OUTPUT_REQ))  )     if ( (Num = Abc_NamStrFind(pNamO, pToken2)) > 0 )  Vec_IntWriteEntry( &p->vOutReqs,  Num-1, Scl_Flt2Int(atof(pToken3)) ); else printf( "Line %d: Cannot find output \"%s\".\n", nLines, pToken2 );
-        else if ( !strcmp(pToken, SCL_DIRECTIVE(SCL_OUTPUT_LOAD)) )     if ( (Num = Abc_NamStrFind(pNamO, pToken2)) > 0 )  Vec_IntWriteEntry( &p->vOutLoads, Num-1, Scl_Flt2Int(atof(pToken3)) ); else printf( "Line %d: Cannot find output \"%s\".\n", nLines, pToken2 );
+        else if ( !strcmp(pToken, ".input_cell")  )     if ( (Num = Abc_NamStrFind(pNamI, pToken2)) > 0 )  Vec_PtrWriteEntry( &p->vInCells,  Num-1, Abc_UtilStrsav(pToken3) );    else printf( "Line %d: Cannot find input \"%s\".\n", nLines, pToken2 );
+        else if ( !strcmp(pToken, ".input_arrival")   )     if ( (Num = Abc_NamStrFind(pNamI, pToken2)) > 0 )  Vec_IntWriteEntry( &p->vInArrs,   Num-1, Scl_Flt2Int(atof(pToken3)) ); else printf( "Line %d: Cannot find input \"%s\".\n", nLines, pToken2 );
+        else if ( !strcmp(pToken, ".input_slew")  )     if ( (Num = Abc_NamStrFind(pNamI, pToken2)) > 0 )  Vec_IntWriteEntry( &p->vInSlews,  Num-1, Scl_Flt2Int(atof(pToken3)) ); else printf( "Line %d: Cannot find input \"%s\".\n", nLines, pToken2 );
+        else if ( !strcmp(pToken, ".input_load")  )     if ( (Num = Abc_NamStrFind(pNamI, pToken2)) > 0 )  Vec_IntWriteEntry( &p->vInLoads,  Num-1, Scl_Flt2Int(atof(pToken3)) ); else printf( "Line %d: Cannot find input \"%s\".\n", nLines, pToken2 );
+        else if ( !strcmp(pToken, ".output_required")  )     if ( (Num = Abc_NamStrFind(pNamO, pToken2)) > 0 )  Vec_IntWriteEntry( &p->vOutReqs,  Num-1, Scl_Flt2Int(atof(pToken3)) ); else printf( "Line %d: Cannot find output \"%s\".\n", nLines, pToken2 );
+        else if ( !strcmp(pToken, ".output_load") )     if ( (Num = Abc_NamStrFind(pNamO, pToken2)) > 0 )  Vec_IntWriteEntry( &p->vOutLoads, Num-1, Scl_Flt2Int(atof(pToken3)) ); else printf( "Line %d: Cannot find output \"%s\".\n", nLines, pToken2 );
         else printf( "Line %d: Skipping unrecognized directive \"%s\".\n", nLines, pToken );
     }
     // set missing defaults
@@ -204,19 +194,19 @@ static inline void Scl_ConWrite( Scl_Con_t * p, char * pFileName )
     }
     fprintf( pFile, ".model %s\n", p->pModelName );
 
-    if ( p->pInCellDef )        fprintf( pFile, ".default_%s %s\n",   SCL_INPUT_CELL,  p->pInCellDef );
-    if ( p->tInArrDef   != 0 )  fprintf( pFile, ".default_%s %.2f\n", SCL_INPUT_ARR,   Scl_Int2Flt(p->tInArrDef) );
-    if ( p->tInSlewDef  != 0 )  fprintf( pFile, ".default_%s %.2f\n", SCL_INPUT_SLEW,  Scl_Int2Flt(p->tInSlewDef) );
-    if ( p->tInLoadDef  != 0 )  fprintf( pFile, ".default_%s %.2f\n", SCL_INPUT_LOAD,  Scl_Int2Flt(p->tInLoadDef) );
-    if ( p->tOutReqDef  != 0 )  fprintf( pFile, ".default_%s %.2f\n", SCL_OUTPUT_REQ,  Scl_Int2Flt(p->tOutReqDef) );
-    if ( p->tOutLoadDef != 0 )  fprintf( pFile, ".default_%s %.2f\n", SCL_OUTPUT_LOAD, Scl_Int2Flt(p->tOutLoadDef) );
-
-    Vec_PtrForEachEntry(char *, &p->vInCells, pName, i) if ( pName && (!p->pInCellDef || strcmp(pName,p->pInCellDef)) )  fprintf( pFile, ".%s %s %s\n",   SCL_INPUT_CELL,  Abc_NamStr(p->pNamI, i+1), pName );
-    Vec_IntForEachEntry( &p->vInArrs, Value, i )        if ( Value != p->tInArrDef )   fprintf( pFile, ".%s %s %.2f\n", SCL_INPUT_ARR,   Abc_NamStr(p->pNamI, i+1), Scl_Int2Flt(Value) );
-    Vec_IntForEachEntry( &p->vInSlews, Value, i )       if ( Value != p->tInSlewDef )  fprintf( pFile, ".%s %s %.2f\n", SCL_INPUT_SLEW,  Abc_NamStr(p->pNamI, i+1), Scl_Int2Flt(Value) );
-    Vec_IntForEachEntry( &p->vInLoads, Value, i )       if ( Value != p->tInLoadDef )  fprintf( pFile, ".%s %s %.2f\n", SCL_INPUT_LOAD,  Abc_NamStr(p->pNamI, i+1), Scl_Int2Flt(Value) );
-    Vec_IntForEachEntry( &p->vOutReqs, Value, i )       if ( Value != p->tOutReqDef )  fprintf( pFile, ".%s %s %.2f\n", SCL_OUTPUT_REQ,  Abc_NamStr(p->pNamO, i+1), Scl_Int2Flt(Value) );
-    Vec_IntForEachEntry( &p->vOutLoads, Value, i )      if ( Value != p->tOutLoadDef ) fprintf( pFile, ".%s %s %.2f\n", SCL_OUTPUT_LOAD, Abc_NamStr(p->pNamO, i+1), Scl_Int2Flt(Value) );
+    if ( p->pInCellDef )        fprintf( pFile, ".default_%s %s\n",   "input_cell",  p->pInCellDef );
+    if ( p->tInArrDef   != 0 )  fprintf( pFile, ".default_%s %.2f\n", "input_arrival",   Scl_Int2Flt(p->tInArrDef) );
+    if ( p->tInSlewDef  != 0 )  fprintf( pFile, ".default_%s %.2f\n", "input_slew",  Scl_Int2Flt(p->tInSlewDef) );
+    if ( p->tInLoadDef  != 0 )  fprintf( pFile, ".default_%s %.2f\n", "input_load",  Scl_Int2Flt(p->tInLoadDef) );
+    if ( p->tOutReqDef  != 0 )  fprintf( pFile, ".default_%s %.2f\n", "output_required",  Scl_Int2Flt(p->tOutReqDef) );
+    if ( p->tOutLoadDef != 0 )  fprintf( pFile, ".default_%s %.2f\n", "output_load", Scl_Int2Flt(p->tOutLoadDef) );
+
+    Vec_PtrForEachEntry(char *, &p->vInCells, pName, i) if ( pName && (!p->pInCellDef || strcmp(pName,p->pInCellDef)) )  fprintf( pFile, ".%s %s %s\n",   "input_cell",  Abc_NamStr(p->pNamI, i+1), pName );
+    Vec_IntForEachEntry( &p->vInArrs, Value, i )        if ( Value != p->tInArrDef )   fprintf( pFile, ".%s %s %.2f\n", "input_arrival",   Abc_NamStr(p->pNamI, i+1), Scl_Int2Flt(Value) );
+    Vec_IntForEachEntry( &p->vInSlews, Value, i )       if ( Value != p->tInSlewDef )  fprintf( pFile, ".%s %s %.2f\n", "input_slew",  Abc_NamStr(p->pNamI, i+1), Scl_Int2Flt(Value) );
+    Vec_IntForEachEntry( &p->vInLoads, Value, i )       if ( Value != p->tInLoadDef )  fprintf( pFile, ".%s %s %.2f\n", "input_load",  Abc_NamStr(p->pNamI, i+1), Scl_Int2Flt(Value) );
+    Vec_IntForEachEntry( &p->vOutReqs, Value, i )       if ( Value != p->tOutReqDef )  fprintf( pFile, ".%s %s %.2f\n", "output_required",  Abc_NamStr(p->pNamO, i+1), Scl_Int2Flt(Value) );
+    Vec_IntForEachEntry( &p->vOutLoads, Value, i )      if ( Value != p->tOutLoadDef ) fprintf( pFile, ".%s %s %.2f\n", "output_load", Abc_NamStr(p->pNamO, i+1), Scl_Int2Flt(Value) );
 
     if ( pFile != stdout )
         fclose ( pFile );
diff --git a/src/misc/extra/extra.h b/src/misc/extra/extra.h
index ffbd468..d76f67e 100644
--- a/src/misc/extra/extra.h
+++ b/src/misc/extra/extra.h
@@ -99,7 +99,7 @@ extern int          Extra_BitMatrixIsClique( Extra_BitMat_t * p );
 /*=== extraUtilFile.c ========================================================*/
 
 extern char *       Extra_FileGetSimilarName( char * pFileNameWrong, char * pS1, char * pS2, char * pS3, char * pS4, char * pS5 );
-extern char *       Extra_FileNameExtension( const char * FileName );
+extern const char *       Extra_FileNameExtension( const char * FileName );
 extern char *       Extra_FileNameAppend( char * pBase, char * pSuffix );
 extern char *       Extra_FileNameGeneric( char * FileName );
 extern char *       Extra_FileNameGenericAppend( char * pBase, char * pSuffix );
diff --git a/src/misc/extra/extraUtilFile.c b/src/misc/extra/extraUtilFile.c
index be6d486..0b1de94 100644
--- a/src/misc/extra/extraUtilFile.c
+++ b/src/misc/extra/extraUtilFile.c
@@ -122,9 +122,9 @@ char * Extra_FileGetSimilarName( char * pFileNameWrong, char * pS1, char * pS2,
   SeeAlso     []
 
 ***********************************************************************/
-char * Extra_FileNameExtension( const char * FileName )
+const char * Extra_FileNameExtension( const char * FileName )
 {
-    char * pDot;
+    const char * pDot;
     // find the last "dot" in the file name, if it is present
     for ( pDot = FileName + strlen(FileName)-1; pDot >= FileName; pDot-- )
         if ( *pDot == '.' )
diff --git a/src/opt/fret/fretInit.c b/src/opt/fret/fretInit.c
index 1a93720..e74756e 100644
--- a/src/opt/fret/fretInit.c
+++ b/src/opt/fret/fretInit.c
@@ -164,7 +164,7 @@ void Abc_FlowRetime_UpdateForwardInit( Abc_Ntk_t * pNtk ) {
   Abc_Obj_t *pObj, *pFanin;
   int i;
 
-  vprintf("\t\tupdating init state\n");
+  /* printf("\t\tupdating init state\n"); */
 
   Abc_NtkIncrementTravId( pNtk );
 
@@ -562,7 +562,7 @@ int Abc_FlowRetime_SolveBackwardInit( Abc_Ntk_t * pNtk ) {
   if (pManMR->fSolutionIsDc) {
     Vec_PtrFree(vDelete);
     Abc_NtkForEachLatch( pNtk, pObj, i ) Abc_LatchSetInitDc( pObj );
-    vprintf("\tno init state computation: all-don't-care solution\n");
+    printf("\tno init state computation: all-don't-care solution\n");
     return 1;
   }
 
@@ -593,7 +593,7 @@ int Abc_FlowRetime_SolveBackwardInit( Abc_Ntk_t * pNtk ) {
       Abc_ObjPrint(stdout, pObj);
 #endif
   
-  vprintf("\tsolving for init state (%d nodes)... ", Abc_NtkObjNum(pManMR->pInitNtk));
+  printf("\tsolving for init state (%d nodes)... ", Abc_NtkObjNum(pManMR->pInitNtk));
   fflush(stdout);
 #ifdef ABC_USE_CUDD
   // convert SOPs to BDD
@@ -613,9 +613,9 @@ int Abc_FlowRetime_SolveBackwardInit( Abc_Ntk_t * pNtk ) {
   result = Abc_NtkMiterSat( pSatNtk, (ABC_INT64_T)500000, (ABC_INT64_T)50000000, 0, NULL, NULL );
 
   if (!result) { 
-    vprintf("SUCCESS\n");
+    printf("SUCCESS\n");
   } else  {    
-    vprintf("FAILURE\n");
+    printf("FAILURE\n");
     return 0;
   }
 
@@ -895,7 +895,7 @@ void Abc_FlowRetime_VerifyBackwardInit( Abc_Ntk_t * pNtk ) {
   Abc_Obj_t *pObj, *pFanin;
   int i;
 
-  vprintf("\t\tupdating init state\n");
+  printf("\t\tupdating init state\n");
 
   Abc_NtkIncrementTravId( pNtk );
 
@@ -1031,7 +1031,7 @@ void Abc_FlowRetime_ConstrainInit( ) {
 
   assert(pManMR->pInitNtk);
 
-  vprintf("\tsearch for initial state conflict...\n");
+  printf("\tsearch for initial state conflict...\n");
 
   vNodes = Abc_NtkDfs(pManMR->pInitNtk, 0);
   n = Vec_PtrSize(vNodes);
@@ -1046,7 +1046,7 @@ void Abc_FlowRetime_ConstrainInit( ) {
 
   // grow initialization constraint
   do {
-    vprintf("\t\t");
+    printf("\t\t");
 
     // find element to add to set...
     low = 0, high = Vec_PtrSize(vNodes);
@@ -1055,10 +1055,10 @@ void Abc_FlowRetime_ConstrainInit( ) {
       
       if (!Abc_FlowRetime_PartialSat( vNodes, mid )) {
         low = mid;
-        vprintf("-");
+        printf("-");
       } else {
         high = mid;
-        vprintf("*");
+        printf("*");
       }
       fflush(stdout);
     }
@@ -1071,7 +1071,7 @@ void Abc_FlowRetime_ConstrainInit( ) {
     // mark its TFO
     pObj = (Abc_Obj_t*)Vec_PtrEntry( vNodes, low );
     Abc_NtkMarkCone_rec( pObj, 1 );
-    vprintf("   conflict term = %d ", low);
+    printf("   conflict term = %d ", low);
 
 #if 0
     printf("init ------\n");
@@ -1084,7 +1084,7 @@ void Abc_FlowRetime_ConstrainInit( ) {
     // add node to constraint
     Abc_FlowRetime_GetInitToOrig( pObj, &pOrigObj, &lag );
     assert(pOrigObj);
-    vprintf(" <=> %d/%d\n", Abc_ObjId(pOrigObj), lag);
+    printf(" <=> %d/%d\n", Abc_ObjId(pOrigObj), lag);
 
 #if 0    
     printf("orig ------\n");
@@ -1225,7 +1225,7 @@ void Abc_FlowRetime_AddInitBias( ) {
   pManMR->pDataArray = ABC_REALLOC( Flow_Data_t, pManMR->pDataArray, pManMR->nNodes + (nConstraints*(pManMR->iteration+1)) );
   memset(pManMR->pDataArray + pManMR->nNodes, 0, sizeof(Flow_Data_t)*(nConstraints*(pManMR->iteration+1)));
 
-  vprintf("\t\tcreating %d bias structures\n", nConstraints);
+  printf("\t\tcreating %d bias structures\n", nConstraints);
 
   Vec_PtrForEachEntry(InitConstraint_t*, pManMR->vInitConstraints, pConstraint, i ) {
     if (pConstraint->pBiasNode) continue;
diff --git a/src/prob/prob.c b/src/prob/prob.c
index 778baa3..e8cc1d2 100644
--- a/src/prob/prob.c
+++ b/src/prob/prob.c
@@ -890,6 +890,7 @@ usage:
 int Pb_CommandGenFiles(Abc_Frame_t* pAbc, int argc, char** argv) {
   Abc_Ntk_t* pNtk;
   float Error, Defect;
+  float* prob;
   char outDir[256], fileName[256], baseName[256], command[1024];
   int numPIs, c;
 
@@ -962,7 +963,7 @@ int Pb_CommandGenFiles(Abc_Frame_t* pAbc, int argc, char** argv) {
   sprintf(command, "probmiter %s", fileName);
   Cmd_CommandExecute(pAbc, command);
   pNtk = Abc_FrameReadNtk(pAbc);
-  float* prob = ABC_ALLOC(float, Abc_NtkPiNum(pNtk));
+  prob = ABC_ALLOC(float, Abc_NtkPiNum(pNtk));
   Abc_Obj_t* pObj;
   int i;
   Abc_NtkForEachPi(pNtk, pObj, i) prob[i] = pObj->dTemp;
diff --git a/src/prob/prob.h b/src/prob/prob.h
index 873edc9..404a195 100644
--- a/src/prob/prob.h
+++ b/src/prob/prob.h
@@ -23,6 +23,7 @@
 ///                          INCLUDES                                ///
 ////////////////////////////////////////////////////////////////////////
 
+#include <gmpxx.h>
 #include "base/abc/abc.h"
 #include "bdd/extrab/extraBdd.h"
 #include "misc/extra/extra.h"
@@ -54,14 +55,16 @@ extern void Pb_PrintDistNtk(Abc_Ntk_t*);
 /*=== probWmc.c ==========================================================*/
 extern void Pb_WriteWMC(Abc_Ntk_t*, char*, int, int);
 /*=== probPmc.c ==========================================================*/
+extern "C" {
 extern void Pb_WritePMC(Abc_Ntk_t*, char*, int);
+}
 /*=== probSsat.c ==========================================================*/
 extern void Pb_WriteSSAT(Abc_Ntk_t*, char*, int, int, int);
 /*=== probBddSp.c ==========================================================*/
-extern float Pb_BddComputeSp(Abc_Ntk_t*, int, int, int, int);
-extern float Pb_BddComputeRESp(Abc_Ntk_t*, int, int, int, int);
+extern mpq_class Pb_BddComputeSp(Abc_Ntk_t*, int, int, int, int);
+extern mpq_class Pb_BddComputeRESp(Abc_Ntk_t*, int, int, int, int);
 extern void Pb_BddComputeAllSp(Abc_Ntk_t*, int, int, int);
-extern float Ssat_BddComputeRESp(Abc_Ntk_t*, DdManager*, int, int, int);
+extern mpq_class Ssat_BddComputeRESp(Abc_Ntk_t*, DdManager*, int, int, int);
 /*=== probMiter.c ==========================================================*/
 extern Abc_Ntk_t* Pb_ProbMiter(Abc_Ntk_t*, Abc_Ntk_t*, int);
 
diff --git a/src/prob/probBddSp.c b/src/prob/probBddSp.c
index 5aea4c0..47231f1 100644
--- a/src/prob/probBddSp.c
+++ b/src/prob/probBddSp.c
@@ -17,6 +17,7 @@
 ***********************************************************************/
 
 #include <stdlib.h>
+#include <gmpxx.h>
 
 #include "aig/saig/saig.h"
 #include "base/abc/abc.h"
@@ -31,6 +32,7 @@ ABC_NAMESPACE_IMPL_START
 ///                        DECLARATIONS                              ///
 ////////////////////////////////////////////////////////////////////////
 
+extern "C" {
 // external methods
 extern void* Abc_NtkBuildGlobalBdds(Abc_Ntk_t*, int, int, int, int);
 extern DdNode* Abc_NodeGlobalBdds_rec(DdManager*, Abc_Obj_t*, int, int,
@@ -38,23 +40,24 @@ extern DdNode* Abc_NodeGlobalBdds_rec(DdManager*, Abc_Obj_t*, int, int,
 extern MtrNode* Cudd_MakeTreeNode(DdManager*, unsigned int, unsigned int,
                                   unsigned int);
 // main methods
-float Pb_BddComputeSp(Abc_Ntk_t*, int, int, int, int);
-float Pb_BddComputeRESp(Abc_Ntk_t*, int, int, int, int);
-float Ssat_BddComputeRESp(Abc_Ntk_t*, DdManager*, int, int, int);
+mpq_class Pb_BddComputeSp(Abc_Ntk_t*, int, int, int, int);
+mpq_class Pb_BddComputeRESp(Abc_Ntk_t*, int, int, int, int);
+mpq_class Ssat_BddComputeRESp(Abc_Ntk_t*, DdManager*, int, int, int);
 void Pb_BddComputeAllSp(Abc_Ntk_t*, int, int, int);
 // helpers
 DdManager* Ssat_NtkPoBuildGlobalBdd(Abc_Ntk_t*, int, int, int);
 int Pb_BddShuffleGroup(DdManager*, int, int);
 void Pb_BddResetProb(DdManager*, DdNode*);
 void BddComputeSsat_rec(Abc_Ntk_t*, DdNode*);
-float Ssat_BddComputeProb_rec(Abc_Ntk_t*, DdNode*, int, int);
+mpq_class Ssat_BddComputeProb_rec(Abc_Ntk_t*, DdNode*, int, int);
 void Nz_DebugBdd(DdNode* bFunc);
 static DdManager* Pb_NtkBuildGlobalBdds(Abc_Ntk_t*, int, int);
 static DdManager* Abc_NtkPoBuildGlobalBdd(Abc_Ntk_t*, int, int, int);
 static void Pb_BddComputeProb(Abc_Ntk_t*, DdNode*, int, int);
-static float Pb_BddComputeProb_rec(Abc_Ntk_t*, DdNode*, int, int);
+static mpq_class Pb_BddComputeProb_rec(Abc_Ntk_t*, DdNode*, int, int);
 static void Pb_BddPrintProb(Abc_Ntk_t*, DdNode*, int);
 static void Pb_BddPrintExSol(Abc_Ntk_t*, DdNode*, int, int);
+}
 
 ////////////////////////////////////////////////////////////////////////
 ///                     FUNCTION DEFINITIONS                         ///
@@ -72,12 +75,12 @@ static void Pb_BddPrintExSol(Abc_Ntk_t*, DdNode*, int, int);
 
 ***********************************************************************/
 
-float Pb_BddComputeSp(Abc_Ntk_t* pNtk, int numPo, int numExist, int fGrp,
+mpq_class Pb_BddComputeSp(Abc_Ntk_t* pNtk, int numPo, int numExist, int fGrp,
                       int fVerbose) {
   DdManager* dd;
   DdNode* bFunc;
   abctime clk;
-  float prob;
+  mpq_class prob;
 
   if (fVerbose)
     printf("  > Pb_BddComputeSp() : build bdd for %d-th Po\n", numPo);
@@ -101,14 +104,14 @@ float Pb_BddComputeSp(Abc_Ntk_t* pNtk, int numPo, int numExist, int fGrp,
       }
     }
   }
-  bFunc = Abc_ObjGlobalBdd(Abc_NtkPo(pNtk, numPo));
+  bFunc = (DdNode*)Abc_ObjGlobalBdd(Abc_NtkPo(pNtk, numPo));
   clk = Abc_Clock();
   Pb_BddResetProb(dd, bFunc);
   Pb_BddComputeProb(pNtk, bFunc, numExist, Cudd_IsComplement(bFunc));
   if (fVerbose) Abc_PrintTime(1, "  > Prob computation", Abc_Clock() - clk);
 
-  prob = Cudd_IsComplement(bFunc) ? 1.0 - Cudd_Regular(bFunc)->pMin
-                                  : Cudd_Regular(bFunc)->pMax;
+  prob = Cudd_IsComplement(bFunc) ? 1.0 - Cudd_Regular(bFunc)->i.value()->pMin
+                                  : Cudd_Regular(bFunc)->i.value()->pMax;
   if (fVerbose) {
     printf("  > %d-th Po", numPo);
     Pb_BddPrintProb(pNtk, bFunc, numExist);
@@ -124,116 +127,120 @@ void Pb_BddComputeProb(Abc_Ntk_t* pNtk, DdNode* bFunc, int numExist, int fNot) {
 void Pb_BddResetProb(DdManager* dd, DdNode* bFunc) {
   DdGen* gen;
   DdNode* node;
-  Cudd_ForeachNode(dd, bFunc, gen, node) Cudd_Regular(node)->pMax =
-      Cudd_Regular(node)->pMin = Cudd_IsConstant(node) ? 1.0 : -1.0;
+  Cudd_ForeachNode(dd, bFunc, gen, node) {
+    if (!Cudd_Regular(node)->i.has_value()) {
+      Cudd_Regular(node)->i = new Indirection;
+    }
+    Cudd_Regular(node)->i.value()->pMax = Cudd_Regular(node)->i.value()->pMin = Cudd_IsConstant(node) ? 1.0 : -1.0;
+  }
 }
 
 // FIXME: this is buggy!!!
 #if 1
-float Pb_BddComputeProb_rec(Abc_Ntk_t* pNtk, DdNode* bFunc, int numExist,
+mpq_class Pb_BddComputeProb_rec(Abc_Ntk_t* pNtk, DdNode* bFunc, int numExist,
                             int fNot) {
-  float prob, pThenMax, pElseMax, pThenMin, pElseMin;
+  mpq_class prob, pThenMax, pElseMax, pThenMin, pElseMin;
   int numPi, fComp;
 
   numPi = Cudd_Regular(bFunc)->index;
   fComp = Cudd_IsComplement(bFunc);
 
   if (Cudd_IsConstant(bFunc)) return Cudd_IsComplement(bFunc) ? 0.0 : 1.0;
-  if (Cudd_Regular(bFunc)->pMax == -1.0) {
+  if (Cudd_Regular(bFunc)->i.value()->pMax == -1.0) {
     // compute value for this node if it is not visited
     if (numPi < numExist) {
       if (fNot) {  // forall var -> min
         pThenMin = Pb_BddComputeProb_rec(pNtk, Cudd_T(bFunc), numExist, fNot);
         pElseMin = Pb_BddComputeProb_rec(pNtk, Cudd_E(bFunc), numExist, fNot);
         pThenMax = Cudd_IsComplement(Cudd_T(bFunc))
-                       ? 1.0 - Cudd_Regular(Cudd_T(bFunc))->pMin
-                       : Cudd_Regular(Cudd_T(bFunc))->pMax;
+                       ? 1.0 - Cudd_Regular(Cudd_T(bFunc))->i.value()->pMin
+                       : Cudd_Regular(Cudd_T(bFunc))->i.value()->pMax;
         pElseMax = Cudd_IsComplement(Cudd_E(bFunc))
-                       ? 1.0 - Cudd_Regular(Cudd_E(bFunc))->pMin
-                       : Cudd_Regular(Cudd_E(bFunc))->pMax;
+                       ? 1.0 - Cudd_Regular(Cudd_E(bFunc))->i.value()->pMin
+                       : Cudd_Regular(Cudd_E(bFunc))->i.value()->pMax;
       } else {  // exist var ->max
         pThenMax = Pb_BddComputeProb_rec(pNtk, Cudd_T(bFunc), numExist, fNot);
         pElseMax = Pb_BddComputeProb_rec(pNtk, Cudd_E(bFunc), numExist, fNot);
         pThenMin = Cudd_IsComplement(Cudd_T(bFunc))
-                       ? 1.0 - Cudd_Regular(Cudd_T(bFunc))->pMax
-                       : Cudd_Regular(Cudd_T(bFunc))->pMin;
+                       ? 1.0 - Cudd_Regular(Cudd_T(bFunc))->i.value()->pMax
+                       : Cudd_Regular(Cudd_T(bFunc))->i.value()->pMin;
         pElseMin = Cudd_IsComplement(Cudd_E(bFunc))
-                       ? 1.0 - Cudd_Regular(Cudd_E(bFunc))->pMax
-                       : Cudd_Regular(Cudd_E(bFunc))->pMin;
+                       ? 1.0 - Cudd_Regular(Cudd_E(bFunc))->i.value()->pMax
+                       : Cudd_Regular(Cudd_E(bFunc))->i.value()->pMin;
         // printf( "pThenMax = %f , pThenMin = %f , pElseMax = %f , pElseMin =
         // %f\n" , pThenMax , pThenMin , pElseMax , pElseMin ); printf( "   >
-        // (exist) %s(%d-th) , pMax = %f , pMin = %f " , Abc_ObjName(
-        // Abc_NtkPi(pNtk,numPi) ) , numPi , Cudd_Regular(bFunc)->pMax ,
-        // Cudd_Regular(bFunc)->pMin ); printf( " cMax = %d , cMin = %d\n" ,
-        // Cudd_Regular(bFunc)->cMax , Cudd_Regular(bFunc)->cMin );
+        // (exist) %s(%d-th) , i->i.value()->pMax = %f , i->i.value()->pMin = %f " , Abc_ObjName(
+        // Abc_NtkPi(pNtk,numPi) ) , numPi , Cudd_Regular(bFunc)->i.value()->pMax ,
+        // Cudd_Regular(bFunc)->i.value()->pMin ); printf( " i.value()->cMax = %d , i.value()->cMin = %d\n" ,
+        // Cudd_Regular(bFunc)->i.value()->cMax , Cudd_Regular(bFunc)->i.value()->cMin );
       }
-      Cudd_Regular(bFunc)->pMax = (pThenMax >= pElseMax) ? pThenMax : pElseMax;
-      Cudd_Regular(bFunc)->pMin = (pThenMin <= pElseMin) ? pThenMin : pElseMin;
-      Cudd_Regular(bFunc)->cMax = (pThenMax >= pElseMax) ? 1 : 0;
-      Cudd_Regular(bFunc)->cMin = (pThenMin <= pElseMin) ? 1 : 0;
+      Cudd_Regular(bFunc)->i.value()->pMax = (pThenMax >= pElseMax) ? pThenMax : pElseMax;
+      Cudd_Regular(bFunc)->i.value()->pMin = (pThenMin <= pElseMin) ? pThenMin : pElseMin;
+      Cudd_Regular(bFunc)->i.value()->cMax = (pThenMax >= pElseMax) ? 1 : 0;
+      Cudd_Regular(bFunc)->i.value()->cMin = (pThenMin <= pElseMin) ? 1 : 0;
     } else {  // random var -> avg
       prob = Abc_NtkPi(pNtk, numPi)->dTemp;
-      Cudd_Regular(bFunc)->pMax = Cudd_Regular(bFunc)->pMin =
+      Cudd_Regular(bFunc)->i.value()->pMax = Cudd_Regular(bFunc)->i.value()->pMin =
           prob * Pb_BddComputeProb_rec(pNtk, Cudd_T(bFunc), numExist, fNot) +
           (1.0 - prob) *
               Pb_BddComputeProb_rec(pNtk, Cudd_E(bFunc), numExist, fNot);
-      // printf( "   > (random) %s , pMax = %f\n" , Abc_ObjName(
-      // Abc_NtkPi(pNtk,numPi) ) , Cudd_Regular(bFunc)->pMax );
+      // printf( "   > (random) %s , i->i.value()->pMax = %f\n" , Abc_ObjName(
+      // Abc_NtkPi(pNtk,numPi) ) , Cudd_Regular(bFunc)->i.value()->pMax );
     }
   }
   if (fNot)
-    return fComp ? 1.0 - Cudd_Regular(bFunc)->pMax : Cudd_Regular(bFunc)->pMin;
+    return fComp ? 1.0 - Cudd_Regular(bFunc)->i.value()->pMax : Cudd_Regular(bFunc)->i.value()->pMin;
   else
-    return fComp ? 1.0 - Cudd_Regular(bFunc)->pMin : Cudd_Regular(bFunc)->pMax;
+    return fComp ? 1.0 - Cudd_Regular(bFunc)->i.value()->pMin : Cudd_Regular(bFunc)->i.value()->pMax;
 }
 #else
-float Pb_BddComputeProb_rec(Abc_Ntk_t* pNtk, DdNode* bFunc, int numExist) {
-  float prob, pThenMax, pElseMax, pThenMin, pElseMin;
+mpq_class Pb_BddComputeProb_rec(Abc_Ntk_t* pNtk, DdNode* bFunc, int numExist) {
+  mpq_class prob, pThenMax, pElseMax, pThenMin, pElseMin;
   int numPi, fComp;
 
   numPi = Cudd_Regular(bFunc)->index;
   fComp = Cudd_IsComplement(bFunc);
 
   if (Cudd_IsConstant(bFunc)) return Cudd_IsComplement(bFunc) ? 0.0 : 1.0;
-  if (Cudd_Regular(bFunc)->pMax == -1.0) {  // unvisited node
+  if (Cudd_Regular(bFunc)->i.value()->pMax == -1.0) {  // unvisited node
     if (numPi < numExist) {                 // exist var -> max / min
       pThenMax = Pb_BddComputeProb_rec(pNtk, Cudd_T(bFunc), numExist);
       pElseMax = Pb_BddComputeProb_rec(pNtk, Cudd_E(bFunc), numExist);
       pThenMin = Cudd_IsComplement(Cudd_T(bFunc))
-                     ? 1.0 - Cudd_Regular(Cudd_T(bFunc))->pMax
-                     : Cudd_Regular(Cudd_T(bFunc))->pMin;
+                     ? 1.0 - Cudd_Regular(Cudd_T(bFunc))->i.value()->pMax
+                     : Cudd_Regular(Cudd_T(bFunc))->i.value()->pMin;
       pElseMin = Cudd_IsComplement(Cudd_E(bFunc))
-                     ? 1.0 - Cudd_Regular(Cudd_E(bFunc))->pMax
-                     : Cudd_Regular(Cudd_E(bFunc))->pMin;
+                     ? 1.0 - Cudd_Regular(Cudd_E(bFunc))->i.value()->pMax
+                     : Cudd_Regular(Cudd_E(bFunc))->i.value()->pMin;
       // printf( "pThenMax = %f , pThenMin = %f , pElseMax = %f , pElseMin =
       // %f\n" , pThenMax , pThenMin , pElseMax , pElseMin );
-      Cudd_Regular(bFunc)->pMax = (pThenMax >= pElseMax) ? pThenMax : pElseMax;
-      Cudd_Regular(bFunc)->pMin = (pThenMin <= pElseMin) ? pThenMin : pElseMin;
-      Cudd_Regular(bFunc)->cMax = (pThenMax >= pElseMax) ? 1 : 0;
-      Cudd_Regular(bFunc)->cMin = (pThenMin <= pElseMin) ? 1 : 0;
-      // printf( "   > (exist) %s(%d-th) , pMax = %f , pMin = %f " ,
+      Cudd_Regular(bFunc)->i.value()->pMax = (pThenMax >= pElseMax) ? pThenMax : pElseMax;
+      Cudd_Regular(bFunc)->i.value()->pMin = (pThenMin <= pElseMin) ? pThenMin : pElseMin;
+      Cudd_Regular(bFunc)->i.value()->cMax = (pThenMax >= pElseMax) ? 1 : 0;
+      Cudd_Regular(bFunc)->i.value()->cMin = (pThenMin <= pElseMin) ? 1 : 0;
+      // printf( "   > (exist) %s(%d-th) , i->i.value()->pMax = %f , i->i.value()->pMin = %f " ,
       // Abc_ObjName( Abc_NtkPi(pNtk,numPi) ) , numPi ,
-      // Cudd_Regular(bFunc)->pMax , Cudd_Regular(bFunc)->pMin ); printf( " cMax
-      // = %d , cMin = %d\n" , Cudd_Regular(bFunc)->cMax ,
-      // Cudd_Regular(bFunc)->cMin );
+      // Cudd_Regular(bFunc)->i.value()->pMax , Cudd_Regular(bFunc)->i.value()->pMin ); printf( " i.value()->cMax
+      // = %d , i.value()->cMin = %d\n" , Cudd_Regular(bFunc)->i.value()->cMax ,
+      // Cudd_Regular(bFunc)->i.value()->cMin );
     } else {  // random var -> avg
       prob = Abc_NtkPi(pNtk, numPi)->dTemp;
-      Cudd_Regular(bFunc)->pMax = Cudd_Regular(bFunc)->pMin =
+      Cudd_Regular(bFunc)->i.value()->pMax = Cudd_Regular(bFunc)->i.value()->pMin =
           prob * Pb_BddComputeProb_rec(pNtk, Cudd_T(bFunc), numExist) +
           (1.0 - prob) * Pb_BddComputeProb_rec(pNtk, Cudd_E(bFunc), numExist);
-      // printf( "   > (random) %s , pMax = %f\n" , Abc_ObjName(
-      // Abc_NtkPi(pNtk,numPi) ) , Cudd_Regular(bFunc)->pMax );
+      // printf( "   > (random) %s , i->i.value()->pMax = %f\n" , Abc_ObjName(
+      // Abc_NtkPi(pNtk,numPi) ) , Cudd_Regular(bFunc)->i.value()->pMax );
     }
   }
-  return fComp ? 1.0 - Cudd_Regular(bFunc)->pMin : Cudd_Regular(bFunc)->pMax;
+  return fComp ? 1.0 - Cudd_Regular(bFunc)->i.value()->pMin : Cudd_Regular(bFunc)->i.value()->pMax;
 }
 #endif
 
 void Pb_BddPrintProb(Abc_Ntk_t* pNtk, DdNode* bFunc, int numExist) {
   // int i , n;
   printf(" , prob = %e\n", Cudd_IsComplement(bFunc)
-                               ? 1.0 - Cudd_Regular(bFunc)->pMin
-                               : Cudd_Regular(bFunc)->pMax);
+                               ? 1.0 - Cudd_Regular(bFunc)->i.value()->pMin
+                               : Cudd_Regular(bFunc)->i.value()->pMax);
   /*if ( Cudd_Regular( bFunc )->index < numExist ) { // exist var
      if ( pNtk->pModel ) printf( "  > [Warning] Reset model\n" );
           else {
@@ -249,7 +256,7 @@ void Pb_BddPrintExSol(Abc_Ntk_t* pNtk, DdNode* bFunc, int numExist, int max) {
   // > max = 1 -> find max ; max = 0 -> find min
   int sol;
   max = max ^ Cudd_IsComplement(bFunc);
-  sol = max ? Cudd_Regular(bFunc)->cMax : Cudd_Regular(bFunc)->cMin;
+  sol = max ? Cudd_Regular(bFunc)->i.value()->cMax : Cudd_Regular(bFunc)->i.value()->cMin;
   if (!Cudd_IsConstant(bFunc) && Cudd_Regular(bFunc)->index < numExist) {
     printf("  > %d-th Pi , sol = %d\n", Cudd_Regular(bFunc)->index, sol);
     pNtk->pModel[Cudd_Regular(bFunc)->index] = sol;
@@ -412,7 +419,7 @@ void Pb_BddComputeAllSp(Abc_Ntk_t* pNtk, int numExist, int fGrp, int fVerbose) {
   // Abc_Obj_t * pObj;
   abctime clk;
   int fReorder, maxId;  // , i;
-  float maxProb;        // , temp;
+  mpq_class maxProb;        // , temp;
 
   fReorder = (numExist > 0) ? 0 : 1;
   maxId = -1;
@@ -450,7 +457,7 @@ void Pb_BddComputeAllSp(Abc_Ntk_t* pNtk, int numExist, int fGrp, int fVerbose) {
          Abc_PrintTime( 1 , "  > Probability computation" , Abc_Clock() - clk );
 	      printf( "Bddsp : numPo = %d " , i );
       }
-		temp = Cudd_IsComplement( bFunc ) ? 1.0-Cudd_Regular(bFunc)->pMin : Cudd_Regular(bFunc)->pMax;
+		temp = Cudd_IsComplement( bFunc ) ? 1.0-Cudd_Regular(bFunc)->i.value()->pMin : Cudd_Regular(bFunc)->i.value()->pMax;
 		if ( temp > maxProb ) {
 		   maxProb = temp;
          maxId   = i;
@@ -580,12 +587,12 @@ DdManager* Pb_NtkBuildGlobalBdds(Abc_Ntk_t* pNtk, int numExist, int fGrp) {
 
 ***********************************************************************/
 
-float Pb_BddComputeRESp(Abc_Ntk_t* pNtk, int numPo, int numRand, int fGrp,
+mpq_class Pb_BddComputeRESp(Abc_Ntk_t* pNtk, int numPo, int numRand, int fGrp,
                         int fVerbose) {
   DdManager* dd;
   DdNode* bFunc;
   abctime clk;
-  float prob;
+  mpq_class prob;
 
   if (fVerbose)
     printf("  > Pb_BddComputeSp() : build bdd for %d-th Po\n", numPo);
@@ -611,13 +618,13 @@ float Pb_BddComputeRESp(Abc_Ntk_t* pNtk, int numPo, int numRand, int fGrp,
       }
     }
   }
-  bFunc = Abc_ObjGlobalBdd(Abc_NtkPo(pNtk, numPo));
+  bFunc = (DdNode*)Abc_ObjGlobalBdd(Abc_NtkPo(pNtk, numPo));
   clk = Abc_Clock();
   Pb_BddResetProb(dd, bFunc);
   BddComputeSsat_rec(pNtk, bFunc);
   if (fVerbose) Abc_PrintTime(1, "  > Prob computation", Abc_Clock() - clk);
-  prob = Cudd_IsComplement(bFunc) ? 1.0 - Cudd_Regular(bFunc)->pMin
-                                  : Cudd_Regular(bFunc)->pMax;
+  prob = Cudd_IsComplement(bFunc) ? 1.0 - Cudd_Regular(bFunc)->i.value()->pMin
+                                  : Cudd_Regular(bFunc)->i.value()->pMax;
   if (fVerbose) printf("  > %d-th Po, sat prob = %f\n", numPo, prob);
   Abc_NtkFreeGlobalBdds(pNtk, 1);
   return prob;
@@ -629,8 +636,8 @@ void Nz_DebugBdd(DdNode* bFunc) {
   else {
     printf("  > node %p , decision var %3d , ", Cudd_Regular(bFunc),
            Cudd_Regular(bFunc)->index);
-    printf(" pMax = %f , pMin = %f\n", Cudd_Regular(bFunc)->pMax,
-           Cudd_Regular(bFunc)->pMin);
+    printf(" i->i.value()->pMax = %f , i->i.value()->pMin = %f\n", Cudd_Regular(bFunc)->i.value()->pMax,
+           Cudd_Regular(bFunc)->i.value()->pMin);
     printf("    > Then-Child of %p\n", Cudd_Regular(bFunc));
     Nz_DebugBdd(Cudd_T(bFunc));
     printf("    > Else-Child of %p\n", Cudd_Regular(bFunc));
@@ -755,52 +762,53 @@ DdManager* Ssat_NtkPoBuildGlobalBdd(Abc_Ntk_t* pNtk, int numPo, int numRand,
 ***********************************************************************/
 
 // FIXME: this is buggy!!! See BddComputeSsat_rec
-float Ssat_BddComputeProb_rec(Abc_Ntk_t* pNtk, DdNode* bFunc, int numRand,
+mpq_class Ssat_BddComputeProb_rec(Abc_Ntk_t* pNtk, DdNode* bFunc, int numRand,
                               int fNot) {
-  float prob, pThenMax, pElseMax, pThenMin, pElseMin;
+  mpq_class prob, pThenMax, pElseMax, pThenMin, pElseMin;
   int numPi, fComp;
 
   numPi = Cudd_Regular(bFunc)->index;
   fComp = Cudd_IsComplement(bFunc);
 
   if (Cudd_IsConstant(bFunc)) return Cudd_IsComplement(bFunc) ? 0.0 : 1.0;
-  if (Cudd_Regular(bFunc)->pMax == -1.0) {  // unvisited node
+  if (Cudd_Regular(bFunc)->i.value()->pMax == -1.0) {  // unvisited node
     if (numPi >= numRand) {
       if (fNot) {  // forall var -> min
         pThenMin = Ssat_BddComputeProb_rec(pNtk, Cudd_T(bFunc), numRand, fNot);
         pElseMin = Ssat_BddComputeProb_rec(pNtk, Cudd_E(bFunc), numRand, fNot);
         pThenMax = Cudd_IsComplement(Cudd_T(bFunc))
-                       ? 1.0 - Cudd_Regular(Cudd_T(bFunc))->pMin
-                       : Cudd_Regular(Cudd_T(bFunc))->pMax;
+                       ? 1.0 - Cudd_Regular(Cudd_T(bFunc))->i.value()->pMin
+                       : Cudd_Regular(Cudd_T(bFunc))->i.value()->pMax;
         pElseMax = Cudd_IsComplement(Cudd_E(bFunc))
-                       ? 1.0 - Cudd_Regular(Cudd_E(bFunc))->pMin
-                       : Cudd_Regular(Cudd_E(bFunc))->pMax;
+                       ? 1.0 - Cudd_Regular(Cudd_E(bFunc))->i.value()->pMin
+                       : Cudd_Regular(Cudd_E(bFunc))->i.value()->pMax;
       } else {  // exist var -> max
         pThenMax = Ssat_BddComputeProb_rec(pNtk, Cudd_T(bFunc), numRand, fNot);
         pElseMax = Ssat_BddComputeProb_rec(pNtk, Cudd_E(bFunc), numRand, fNot);
         pThenMin = Cudd_IsComplement(Cudd_T(bFunc))
-                       ? 1.0 - Cudd_Regular(Cudd_T(bFunc))->pMax
-                       : Cudd_Regular(Cudd_T(bFunc))->pMin;
+                       ? 1.0 - Cudd_Regular(Cudd_T(bFunc))->i.value()->pMax
+                       : Cudd_Regular(Cudd_T(bFunc))->i.value()->pMin;
         pElseMin = Cudd_IsComplement(Cudd_E(bFunc))
-                       ? 1.0 - Cudd_Regular(Cudd_E(bFunc))->pMax
-                       : Cudd_Regular(Cudd_E(bFunc))->pMin;
+                       ? 1.0 - Cudd_Regular(Cudd_E(bFunc))->i.value()->pMax
+                       : Cudd_Regular(Cudd_E(bFunc))->i.value()->pMin;
       }
-      Cudd_Regular(bFunc)->pMax = (pThenMax >= pElseMax) ? pThenMax : pElseMax;
-      Cudd_Regular(bFunc)->pMin = (pThenMin <= pElseMin) ? pThenMin : pElseMin;
-      Cudd_Regular(bFunc)->cMax = (pThenMax >= pElseMax) ? 1 : 0;
-      Cudd_Regular(bFunc)->cMin = (pThenMin <= pElseMin) ? 1 : 0;
+      Cudd_Regular(bFunc)->i.value()->pMax = (pThenMax >= pElseMax) ? pThenMax : pElseMax;
+      Cudd_Regular(bFunc)->i.value()->pMin = (pThenMin <= pElseMin) ? pThenMin : pElseMin;
+      Cudd_Regular(bFunc)->i.value()->cMax = (pThenMax >= pElseMax) ? 1 : 0;
+      Cudd_Regular(bFunc)->i.value()->cMin = (pThenMin <= pElseMin) ? 1 : 0;
     } else {  // random var -> avg
       prob = Abc_NtkPi(pNtk, numPi)->dTemp;
-      Cudd_Regular(bFunc)->pMax = Cudd_Regular(bFunc)->pMin =
+      Cudd_Regular(bFunc)->i.value()->pMax = Cudd_Regular(bFunc)->i.value()->pMin =
           prob * Ssat_BddComputeProb_rec(pNtk, Cudd_T(bFunc), numRand, fNot) +
           (1.0 - prob) *
               Ssat_BddComputeProb_rec(pNtk, Cudd_E(bFunc), numRand, fNot);
+
     }
   }
   if (fNot)  // forall quantified!
-    return fComp ? 1.0 - Cudd_Regular(bFunc)->pMax : Cudd_Regular(bFunc)->pMin;
+    return fComp ? 1.0 - Cudd_Regular(bFunc)->i.value()->pMax : Cudd_Regular(bFunc)->i.value()->pMin;
   else
-    return fComp ? 1.0 - Cudd_Regular(bFunc)->pMin : Cudd_Regular(bFunc)->pMax;
+    return fComp ? 1.0 - Cudd_Regular(bFunc)->i.value()->pMin : Cudd_Regular(bFunc)->i.value()->pMax;
 }
 
 /**Function*************************************************************
@@ -816,36 +824,36 @@ float Ssat_BddComputeProb_rec(Abc_Ntk_t* pNtk, DdNode* bFunc, int numRand,
 ***********************************************************************/
 
 void BddComputeSsat_rec(Abc_Ntk_t* pNtk, DdNode* bFunc) {
-  float prob, pThenMax, pElseMax, pThenMin, pElseMin;
+  mpq_class prob, pThenMax, pElseMax, pThenMin, pElseMin;
   int numPi, fComp;
 
   numPi = Cudd_Regular(bFunc)->index;
   fComp = Cudd_IsComplement(bFunc);
 
-  if (Cudd_IsConstant(bFunc) || Cudd_Regular(bFunc)->pMax != -1.0) return;
+  if (Cudd_IsConstant(bFunc) || Cudd_Regular(bFunc)->i.value()->pMax != -1.0) return;
   BddComputeSsat_rec(pNtk, Cudd_T(bFunc));
   BddComputeSsat_rec(pNtk, Cudd_E(bFunc));
   pThenMax = Cudd_IsComplement(Cudd_T(bFunc))
-                 ? 1.0 - Cudd_Regular(Cudd_T(bFunc))->pMin
-                 : Cudd_Regular(Cudd_T(bFunc))->pMax;
+                 ? 1.0 - Cudd_Regular(Cudd_T(bFunc))->i.value()->pMin
+                 : Cudd_Regular(Cudd_T(bFunc))->i.value()->pMax;
   pElseMax = Cudd_IsComplement(Cudd_E(bFunc))
-                 ? 1.0 - Cudd_Regular(Cudd_E(bFunc))->pMin
-                 : Cudd_Regular(Cudd_E(bFunc))->pMax;
+                 ? 1.0 - Cudd_Regular(Cudd_E(bFunc))->i.value()->pMin
+                 : Cudd_Regular(Cudd_E(bFunc))->i.value()->pMax;
   pThenMin = Cudd_IsComplement(Cudd_T(bFunc))
-                 ? 1.0 - Cudd_Regular(Cudd_T(bFunc))->pMax
-                 : Cudd_Regular(Cudd_T(bFunc))->pMin;
+                 ? 1.0 - Cudd_Regular(Cudd_T(bFunc))->i.value()->pMax
+                 : Cudd_Regular(Cudd_T(bFunc))->i.value()->pMin;
   pElseMin = Cudd_IsComplement(Cudd_E(bFunc))
-                 ? 1.0 - Cudd_Regular(Cudd_E(bFunc))->pMax
-                 : Cudd_Regular(Cudd_E(bFunc))->pMin;
+                 ? 1.0 - Cudd_Regular(Cudd_E(bFunc))->i.value()->pMax
+                 : Cudd_Regular(Cudd_E(bFunc))->i.value()->pMin;
   prob = Abc_NtkPi(pNtk, numPi)->dTemp;
   if (prob == -1.0) {  // exist var
-    Cudd_Regular(bFunc)->pMax = (pThenMax >= pElseMax) ? pThenMax : pElseMax;
-    Cudd_Regular(bFunc)->cMax = (pThenMax >= pElseMax) ? 1 : 0;
-    Cudd_Regular(bFunc)->pMin = (pThenMin <= pElseMin) ? pThenMin : pElseMin;
-    Cudd_Regular(bFunc)->cMin = (pThenMin <= pElseMin) ? 1 : 0;
+    Cudd_Regular(bFunc)->i.value()->pMax = (pThenMax >= pElseMax) ? pThenMax : pElseMax;
+    Cudd_Regular(bFunc)->i.value()->cMax = (pThenMax >= pElseMax) ? 1 : 0;
+    Cudd_Regular(bFunc)->i.value()->pMin = (pThenMin <= pElseMin) ? pThenMin : pElseMin;
+    Cudd_Regular(bFunc)->i.value()->cMin = (pThenMin <= pElseMin) ? 1 : 0;
   } else {  // random var
-    Cudd_Regular(bFunc)->pMax = prob * pThenMax + (1.0 - prob) * pElseMax;
-    Cudd_Regular(bFunc)->pMin = prob * pThenMin + (1.0 - prob) * pElseMin;
+    Cudd_Regular(bFunc)->i.value()->pMax = prob * pThenMax + (1.0 - prob) * pElseMax;
+    Cudd_Regular(bFunc)->i.value()->pMin = prob * pThenMin + (1.0 - prob) * pElseMin;
   }
 }
 
@@ -861,12 +869,12 @@ void BddComputeSsat_rec(Abc_Ntk_t* pNtk, DdNode* bFunc) {
 
 ***********************************************************************/
 
-float Ssat_BddComputeRESp(Abc_Ntk_t* pNtk, DdManager* dd, int numPo,
+mpq_class Ssat_BddComputeRESp(Abc_Ntk_t* pNtk, DdManager* dd, int numPo,
                           int numRand, int fGrp) {
   ProgressBar* pProgress;
   Abc_Obj_t *pObj, *pFanin;
   DdNode* bFunc;
-  float prob;
+  mpq_class prob;
   int fDropInternal, Counter, i, k;
 
   fDropInternal = 1;
@@ -900,11 +908,11 @@ float Ssat_BddComputeRESp(Abc_Ntk_t* pNtk, DdManager* dd, int numPo,
       }
     }
   }
-  bFunc = Abc_ObjGlobalBdd(Abc_NtkPo(pNtk, numPo));
+  bFunc = (DdNode*)Abc_ObjGlobalBdd(Abc_NtkPo(pNtk, numPo));
   Pb_BddResetProb(dd, bFunc);
   BddComputeSsat_rec(pNtk, bFunc);
-  prob = Cudd_IsComplement(bFunc) ? 1.0 - Cudd_Regular(bFunc)->pMin
-                                  : Cudd_Regular(bFunc)->pMax;
+  prob = Cudd_IsComplement(bFunc) ? 1.0 - Cudd_Regular(bFunc)->i.value()->pMin
+                                  : Cudd_Regular(bFunc)->i.value()->pMax;
   return prob;
 }
 
diff --git a/src/prob/probDistill.c b/src/prob/probDistill.c
index 6c01c3d..6920931 100644
--- a/src/prob/probDistill.c
+++ b/src/prob/probDistill.c
@@ -31,8 +31,11 @@ ABC_NAMESPACE_IMPL_START
 
 // external methods
 // main methods
+extern "C" {
 Abc_Ntk_t* Pb_DistillNtk(Abc_Ntk_t*);
 void Pb_PrintDistNtk(Abc_Ntk_t*);
+}
+
 // helpers
 static void Pb_DistillCreatePio(Abc_Ntk_t*, Abc_Ntk_t*);
 static void Pb_DistillCreateGate(Abc_Ntk_t*, Abc_Ntk_t*);
@@ -85,13 +88,13 @@ void Pb_DistillCreatePio(Abc_Ntk_t* pNtkDist, Abc_Ntk_t* pNtk) {
 
   Abc_NtkForEachPi(pNtk, pObj, i) {
     pObj->pData = Abc_NtkCreatePi(pNtkDist);
-    Abc_ObjAssignName(pObj->pData, Abc_ObjName(pObj), "_d");
+    Abc_ObjAssignName((Abc_Obj_t*)pObj->pData, Abc_ObjName(pObj), "_d");
     ((Abc_Obj_t*)(pObj->pData))->dTemp = pObj->dTemp;
   }
 
   Abc_NtkForEachPo(pNtk, pObj, i) {
     pObj->pData = Abc_NtkCreatePo(pNtkDist);
-    Abc_ObjAssignName(pObj->pData, Abc_ObjName(pObj), "_d");
+    Abc_ObjAssignName((Abc_Obj_t*)pObj->pData, Abc_ObjName(pObj), "_d");
   }
 }
 
@@ -100,14 +103,14 @@ void Pb_DistillCreateGate(Abc_Ntk_t* pNtkDist, Abc_Ntk_t* pNtk) {
   int i;
 
   Abc_AigForEachAnd(pNtk, pObj, i) {
-    pObj->pData = Abc_AigAnd(pNtkDist->pManFunc, Abc_ObjChild0Data(pObj),
+    pObj->pData = Abc_AigAnd((Abc_Aig_t*)pNtkDist->pManFunc, Abc_ObjChild0Data(pObj),
                              Abc_ObjChild1Data(pObj));
     if (pObj->dTemp != 0.0) {
       // distillation process
       pObjAi = Abc_NtkCreatePi(pNtkDist);
       Abc_ObjAssignName(pObjAi, Abc_ObjName(pObj), "_ai");
       pObjAi->dTemp = pObj->dTemp;
-      pObj->pData = Abc_AigXor(pNtkDist->pManFunc, pObj->pData, pObjAi);
+      pObj->pData = Abc_AigXor((Abc_Aig_t*)pNtkDist->pManFunc, (Abc_Obj_t*)pObj->pData, pObjAi);
     }
   }
 }
@@ -117,7 +120,7 @@ void Pb_DistillFinalize(Abc_Ntk_t* pNtkDist, Abc_Ntk_t* pNtk) {
   int i;
 
   Abc_NtkForEachPo(pNtk, pObj, i)
-      Abc_ObjAddFanin(pObj->pData, Abc_ObjChild0Data(pObj));
+      Abc_ObjAddFanin((Abc_Obj_t*)pObj->pData, Abc_ObjChild0Data(pObj));
 }
 
 /**Function*************************************************************
diff --git a/src/prob/probIo.c b/src/prob/probIo.c
index f58bdf6..a91e94f 100644
--- a/src/prob/probIo.c
+++ b/src/prob/probIo.c
@@ -32,8 +32,10 @@ ABC_NAMESPACE_IMPL_START
 // external methods
 extern float randProb();
 // main methods
+extern "C" {
 void Pb_GenProbNtk(Abc_Ntk_t*, float, float);
 void Pb_WritePBN(Abc_Ntk_t*, char*, int, int);
+}
 // helpers
 static void Pb_CountErrorGates(Abc_Ntk_t*);
 static void Pb_WritePBNPio(FILE*, Abc_Ntk_t*, int);
diff --git a/src/prob/probMiter.c b/src/prob/probMiter.c
index fc3473d..4325c1f 100644
--- a/src/prob/probMiter.c
+++ b/src/prob/probMiter.c
@@ -31,7 +31,9 @@ ABC_NAMESPACE_IMPL_START
 
 // external methods
 // main methods
+extern "C" {
 Abc_Ntk_t* Pb_ProbMiter(Abc_Ntk_t*, Abc_Ntk_t*, int);
+}
 // helpers
 
 ////////////////////////////////////////////////////////////////////////
diff --git a/src/prob/probPmc.c b/src/prob/probPmc.c
index 55eb3d4..0fffb91 100644
--- a/src/prob/probPmc.c
+++ b/src/prob/probPmc.c
@@ -27,9 +27,11 @@ ABC_NAMESPACE_IMPL_START
 ////////////////////////////////////////////////////////////////////////
 
 // external methods
+extern "C" {
 extern void Pb_WriteWMCCla(FILE*, Abc_Ntk_t*, int);
 // main methods
 void Pb_WritePMC(Abc_Ntk_t*, char*, int);
+}
 // helpers
 void Pb_CollectIndVar(Abc_Ntk_t*, Vec_Int_t*);
 void Pb_WritePMCIndVar(FILE*, Vec_Int_t*);
diff --git a/src/prob/probSsat.c b/src/prob/probSsat.c
index 736e145..d272daf 100644
--- a/src/prob/probSsat.c
+++ b/src/prob/probSsat.c
@@ -30,9 +30,11 @@ ABC_NAMESPACE_IMPL_START
 ////////////////////////////////////////////////////////////////////////
 
 // external methods
+extern "C" {
 extern void Pb_WriteWMCCla(FILE*, Abc_Ntk_t*, int);
 // main methods
 void Pb_WriteSSAT(Abc_Ntk_t*, char*, int, int, int);
+}
 // helpers
 static void Pb_WriteQdimacsPrefix(FILE*, Abc_Ntk_t*, int, int);
 static void Pb_WriteSSATprefix(FILE*, Abc_Ntk_t*, int, int);
diff --git a/src/prob/probWmc.c b/src/prob/probWmc.c
index f240604..3a0f9e5 100644
--- a/src/prob/probWmc.c
+++ b/src/prob/probWmc.c
@@ -31,10 +31,14 @@ ABC_NAMESPACE_IMPL_START
 
 // external methods
 // main methods
+extern "C" {
 void Pb_WriteWMC(Abc_Ntk_t*, char*, int, int);
 // helpers
+extern "C" {
 void Pb_WriteWMCCla(FILE*, Abc_Ntk_t*, int);
+}
 static void Pb_WriteWMCWeight(FILE*, Abc_Ntk_t*, int, int);
+}
 
 ////////////////////////////////////////////////////////////////////////
 ///                     FUNCTION DEFINITIONS                         ///
@@ -52,6 +56,7 @@ static void Pb_WriteWMCWeight(FILE*, Abc_Ntk_t*, int, int);
 
 ***********************************************************************/
 
+extern "C" {
 void Pb_WriteWMC(Abc_Ntk_t* pNtk, char* name, int numPo, int fModel) {
   FILE* out;
   int numVar, numCla;
@@ -73,6 +78,7 @@ void Pb_WriteWMC(Abc_Ntk_t* pNtk, char* name, int numPo, int fModel) {
   Abc_Print(-2, "File %s is written.\n", name);
 }
 
+extern "C" {
 void Pb_WriteWMCCla(FILE* out, Abc_Ntk_t* pNtk, int numPo) {
   Abc_Obj_t *pObj, *pFanin0, *pFanin1;
   int i;
@@ -118,6 +124,9 @@ void Pb_WriteWMCCla(FILE* out, Abc_Ntk_t* pNtk, int numPo) {
   fprintf(out, "%d 0\n", Abc_ObjId(pObj));
 }
 
+}
+}
+
 void Pb_WriteWMCWeight(FILE* out, Abc_Ntk_t* pNtk, int numPo, int fModel) {
   Abc_Obj_t* pObj;
   int i;
diff --git a/src/sat/xsat/xsatSolver.c b/src/sat/xsat/xsatSolver.c
index 481def4..f46c147 100644
--- a/src/sat/xsat/xsatSolver.c
+++ b/src/sat/xsat/xsatSolver.c
@@ -800,7 +800,7 @@ void xSAT_SolverReduceDB( xSAT_Solver_t * s )
 
     limit = nLearnedOld / 2;
 
-    xSAT_UtilSort((void *) learnts_cls, nLearnedOld,
+    xSAT_UtilSort((void **) learnts_cls, nLearnedOld,
                   (int (*)( const void *, const void * )) xSAT_ClauseCompare);
 
     if ( learnts_cls[nLearnedOld / 2]->nLBD <= 3 )
diff --git a/src/ssat/core/SsatSolver.cc b/src/ssat/core/SsatSolver.cc
index f2e2340..9d6feda 100644
--- a/src/ssat/core/SsatSolver.cc
+++ b/src/ssat/core/SsatSolver.cc
@@ -119,7 +119,7 @@ Solver* SsatSolver::parse_SDIMACS(gzFile& input_stream) {
   vec<Lit> lits;
   Solver* ptrS = new Solver;
   Solver& S = *ptrS;
-  double parsed_prob;
+  mpq_class parsed_prob;
   int vars = 0;
   int clauses = 0;
   int cnt = 0;
@@ -183,7 +183,7 @@ Solver* SsatSolver::parse_SDIMACS(gzFile& input_stream) {
   return ptrS;
 }
 
-void SsatSolver::readPrefix(StreamBuffer& in, Solver& S, double prob, int cur,
+void SsatSolver::readPrefix(StreamBuffer& in, Solver& S, mpq_class prob, int cur,
                             int& quan, int& level) {
   vec<int> parsed;
   int parsed_int, var, max = -1;
@@ -205,7 +205,7 @@ void SsatSolver::readPrefix(StreamBuffer& in, Solver& S, double prob, int cur,
   _level.growTo(max, -1);
   for (int i = 0; i < parsed.size(); ++i) {
     (_rootVars.last()).push(parsed[i] - 1);
-    _quan[parsed[i] - 1] = prob;
+    _quan[parsed[i] - 1] = prob.get_d();
     _level[parsed[i] - 1] = level;
   }
 }
@@ -358,7 +358,7 @@ void SsatSolver::qSolve2SSAT(Ssat_Params_t* pParams) {
       if (unsatCubeListFull()) {
         printf("  > Collect %d UNSAT cubes, convert to network\n", _upperLimit);
         _unsatPb = cubeToNetwork(false);
-        printf("  > current unsat prob = %f\n", _unsatPb);
+        std::cout << "current unsat prob = " << _unsatPb << std::endl;
         Abc_PrintTime(1, "  > current unsat time", Abc_Clock() - clk);
         fflush(stdout);
       }
@@ -371,7 +371,7 @@ void SsatSolver::qSolve2SSAT(Ssat_Params_t* pParams) {
       if (satCubeListFull()) {
         printf("  > Collect %d SAT cubes, convert to network\n", _lowerLimit);
         _satPb = cubeToNetwork(true);
-        printf("  > current sat prob = %f\n", _satPb);
+        std::cout << "current sat prob = " << _satPb << std::endl;
         Abc_PrintTime(1, "  > current sat time", Abc_Clock() - clk);
         fflush(stdout);
       }
@@ -423,8 +423,8 @@ void SsatSolver::collectBkCla(vec<Lit>& sBkCla) {
   }
 }
 
-double SsatSolver::baseProb() const {
-  double subspace_base = 1.0;
+mpq_class SsatSolver::baseProb() const {
+  mpq_class subspace_base = 1.0;
   for (int i = 0; i < _rootVars[0].size(); ++i) {
     if (_s2->value(_rootVars[0][i]) == l_True)
       subspace_base *= _quan[_rootVars[0][i]];
@@ -486,10 +486,10 @@ void SsatSolver::dumpCla(const Clause& c) const {
 void SsatSolver::reportSolvingResults() const {
   Abc_Print(-2, "\n==== Solving results ====\n\n");
   if (_fExactlySolved) {
-    Abc_Print(-2, "  > Satisfying probability: %e\n", _exactSatProb);
+    std::cout << "  > Satisfying probability: " << _exactSatProb << endl;
   } else {
-    Abc_Print(-2, "  > Best upper bound: %e\n", upperBound());
-    Abc_Print(-2, "  > Best lower bound: %e\n", lowerBound());
+    std::cout << "  > Best upper bound: " << upperBound() << endl;
+    std::cout << "  > Best lower bound: " << lowerBound() << endl;
     Abc_PrintTime(1, "  > Time elapsed for best lower bound ", timer.timeBest);
   }
 }
@@ -512,7 +512,7 @@ void SsatSolver::test() const {
     printf("Lv%d vars:\n", i);
     for (int j = 0; j < _rootVars[i].size(); ++j) {
       if (isRVar(_rootVars[i][j]))
-        printf("r %f %d\n", _quan[_rootVars[i][j]], _rootVars[i][j] + 1);
+        std::cout << "r " << _quan[_rootVars[i][j]] << " " << _rootVars[i][j] + 1 << std::endl;
       else if (isEVar(_rootVars[i][j]))
         printf("e %d\n", _rootVars[i][j] + 1);
       else if (isAVar(_rootVars[i][j]))
@@ -565,7 +565,7 @@ void SsatSolver::interrupt() {
       } else {
         clk = Abc_Clock();
         _unsatPb = _pNtkCube ? cubeToNetwork(false) : cachetCount(false);
-        Abc_Print(-2, "  > Best upper bound: %e\n", upperBound());
+        std::cout << "  > Best upper bound: " << upperBound() << endl;
         Abc_PrintTime(1, "Time elapsed for upper bound", Abc_Clock() - clk);
       }
       fflush(stdout);
@@ -579,7 +579,7 @@ void SsatSolver::interrupt() {
       } else {
         clk = Abc_Clock();
         _satPb = _pNtkCube ? cubeToNetwork(true) : cachetCount(true);
-        Abc_Print(-2, "  > Best lower bound: %e\n", lowerBound());
+        std::cout << "  > Best lower bound: " << lowerBound() << endl;
         Abc_PrintTime(1, "Time elapsed for lower bound", Abc_Clock() - clk);
       }
       fflush(stdout);
diff --git a/src/ssat/core/SsatSolver.h b/src/ssat/core/SsatSolver.h
index 4ff444a..39fb356 100644
--- a/src/ssat/core/SsatSolver.h
+++ b/src/ssat/core/SsatSolver.h
@@ -28,6 +28,7 @@
 #include <iostream>
 #include <map>
 #include <set>
+#include <gmpxx.h>
 
 // minisat headers
 #include "ssat/core/Solver.h"
@@ -84,7 +85,7 @@ typedef struct Ssat_Timer_t_ {
 // parameters for SsatSolver
 typedef struct Ssat_ParamsStruct_t_ {
   // reSSAT
-  double range;  // acceptable gap between upper and lower bounds
+  mpq_class range;  // acceptable gap between upper and lower bounds
   int upper;     // #UNSAT cubes to compute upper bounds (-1: compute only once)
   int lower;     // #SAT   cubes to compute lower bounds (-1: compute only once)
   // erSSAT
@@ -137,9 +138,9 @@ class SsatSolver {
   // Results reporting
   void reportSolvingResults() const;
   // get statistics
-  double exactSatProb() const { return _exactSatProb; }
-  double upperBound() const { return 1.0 - _unsatPb; }
-  double lowerBound() const { return _satPb; }
+  mpq_class exactSatProb() const { return _exactSatProb; }
+  mpq_class upperBound() const { return 1.0 - _unsatPb; }
+  mpq_class lowerBound() const { return _satPb; }
   int nSatCube() const { return _nSatCube; }
   int nUnsatCube() const { return _nUnsatCube; }
   // Testing interface:
@@ -151,7 +152,7 @@ class SsatSolver {
   // member functions
   // parser helpers
   Solver* parse_SDIMACS(gzFile&);
-  void readPrefix(StreamBuffer&, Solver&, double, int, int&, int&);
+  void readPrefix(StreamBuffer&, Solver&, mpq_class, int, int&, int&);
   // solve interface
   void qSolve(Ssat_Params_t*);        // Qesto-like solve
   void aSolve(Ssat_Params_t*);        // All-SAT enumeration solve
@@ -164,7 +165,7 @@ class SsatSolver {
   void collectBkClaERSub(vec<Lit>&, bool);
   void discardLit(Ssat_Params_t*, vec<Lit>&);
   void discardAllLit(Ssat_Params_t*, vec<Lit>&);
-  double erSolveWMC(Ssat_Params_t*, const vec<Lit>&, const vec<bool>&, int);
+  mpq_class erSolveWMC(Ssat_Params_t*, const vec<Lit>&, const vec<bool>&, int);
   // branch and bound helpers
   void ntkBuildPrefix(Abc_Ntk_t*);
   Solver* ntkBuildSolver(Abc_Ntk_t*, bool);
@@ -184,9 +185,9 @@ class SsatSolver {
   void miniHitOneHotLit(vec<Lit>&, vec<bool>&) const;
   void miniHitCollectLit(vec<Lit>&, vec<Lit>&, vec<bool>&) const;
   void miniHitDropLit(vec<Lit>&, vec<Lit>&, vec<bool>&) const;
-  double cachetCount(bool);
-  double baseProb() const;
-  double countModels(const vec<Lit>&, int);
+  mpq_class cachetCount(bool);
+  mpq_class baseProb() const;
+  mpq_class countModels(const vec<Lit>&, int);
   void buildSubsumeTable(Solver&);
   bool checkSubsume(const vec<int>&, int) const;
   bool subsume(const Clause&, const Clause&) const;
@@ -208,30 +209,30 @@ class SsatSolver {
     return (_lowerLimit != -1) && (_satClause.size() > 0) &&
            (_satClause.size() % _lowerLimit == 0);
   };
-  double cubeToNetwork(bool);
+  mpq_class cubeToNetwork(bool);
   void ntkCreatePi(Abc_Ntk_t*, Vec_Ptr_t*);
   void ntkCreatePo(Abc_Ntk_t*);
   void ntkCreateSelDef(Abc_Ntk_t*, Vec_Ptr_t*);
   Abc_Obj_t* ntkCreateNode(Abc_Ntk_t*, Vec_Ptr_t*, bool);
   void ntkPatchPoCheck(Abc_Ntk_t*, Abc_Obj_t*, bool);
   void ntkWriteWcnf(Abc_Ntk_t*);
-  double ntkBddComputeSp(Abc_Ntk_t*, bool);
+  mpq_class ntkBddComputeSp(Abc_Ntk_t*, bool);
   // construct circuits from clauses for ER-2SSAT
   void initERBddCount(Ssat_Params_t*);
   void initClauseNetwork(bool, bool);
   void erNtkCreatePi(Abc_Ntk_t*, Vec_Ptr_t*);
   void erNtkCreatePo(Abc_Ntk_t*);
-  double bddCountWeight(Ssat_Params_t*, const vec<Lit>&, const vec<bool>&);
-  double clauseToNetwork(const vec<Lit>&, const vec<bool>&, bool, bool);
+  mpq_class bddCountWeight(Ssat_Params_t*, const vec<Lit>&, const vec<bool>&);
+  mpq_class clauseToNetwork(const vec<Lit>&, const vec<bool>&, bool, bool);
   Abc_Obj_t* erNtkCreateNode(Abc_Ntk_t*, Vec_Ptr_t*, const vec<Lit>&,
                              const vec<bool>&);
   DdNode* erNtkCreateBdd(DdManager*, Vec_Ptr_t*, const vec<Lit>&,
                          const vec<bool>&, int, int);
   void erNtkPatchPoCheck(Abc_Ntk_t*, Abc_Obj_t*);
   DdManager* erInitCudd(int, int, int);
-  double erNtkBddComputeSp(Abc_Ntk_t*, bool);
+  mpq_class erNtkBddComputeSp(Abc_Ntk_t*, bool);
   // All-Sat enumeration-based model counting
-  double allSatModelCount(Solver*, const vec<Lit>&, double);
+  mpq_class allSatModelCount(Solver*, const vec<Lit>&, mpq_class);
   // Bdd solving subroutines
   void initCnfNetwork();
   void cnfNtkCreatePi(Abc_Ntk_t*, vec<int>&);
@@ -276,10 +277,10 @@ class SsatSolver {
   Abc_Obj_t* _pConst0;   // network Const0 node
   Abc_Obj_t* _pConst1;   // network Const1 node
   bool _fExactlySolved;  // flag indicating exact solution exists
-  double _exactSatProb;  // satisfying probability when input is exactly
+  mpq_class _exactSatProb;  // satisfying probability when input is exactly
                          // solved
-  double _unsatPb;       // current UNSAT pb, uppper bound
-  double _satPb;         // current SAT pb, lower bound
+  mpq_class _unsatPb;       // current UNSAT pb, uppper bound
+  mpq_class _satPb;         // current SAT pb, lower bound
   int _nSatCube;         // number of collected SAT cubes
   int _nUnsatCube;       // number of collected UNSAT cubes
   int _upperLimit;       // number of UNSAT cubes to invoke network construction
@@ -294,7 +295,7 @@ class SsatSolver {
   vec<DdNode*> _claNodes;        // clause id --> DdNode*
   vec<vec<Lit>> _unitClause;     // unit clause literals
   vec<vec<Lit>> _dupClause;      // copy of s1 clauses
-  double _unitClauseMultiplier;  // The multiplier induced by unit clauses with
+  mpq_class _unitClauseMultiplier;  // The multiplier induced by unit clauses with
                                  // random variables
 };
 
diff --git a/src/ssat/core/ssat.cc b/src/ssat/core/ssat.cc
index 0a1c61d..0daa6e5 100644
--- a/src/ssat/core/ssat.cc
+++ b/src/ssat/core/ssat.cc
@@ -70,6 +70,7 @@ map<string, double> quanMap;  // Pi name -> quan prob , -1 means exist
 
 ***********************************************************************/
 
+extern "C" {
 void Ssat_Init(Abc_Frame_t* pAbc) {
   gloSsat = NULL;
   signal(SIGINT, sig_handler);
@@ -88,6 +89,7 @@ void Ssat_End(Abc_Frame_t* pAbc) {
     gloSsat = NULL;
   }
 }
+}
 
 /**Function*************************************************************
 
diff --git a/src/ssat/core/ssatAllSolve.cc b/src/ssat/core/ssatAllSolve.cc
index 0b78c52..c7e9611 100644
--- a/src/ssat/core/ssatAllSolve.cc
+++ b/src/ssat/core/ssatAllSolve.cc
@@ -267,7 +267,7 @@ void SsatSolver::aSolve2SSAT(Ssat_Params_t* pParams) {
   }
 }
 
-double SsatSolver::cachetCount(bool sat) {
+mpq_class SsatSolver::cachetCount(bool sat) {
   FILE* file;
   int length = 256;
   char prob_str[length], cmdModelCount[length], cmdCleanTempFiles[length];
diff --git a/src/ssat/core/ssatBddSolve.cc b/src/ssat/core/ssatBddSolve.cc
index 8e641ff..be4ccd9 100644
--- a/src/ssat/core/ssatBddSolve.cc
+++ b/src/ssat/core/ssatBddSolve.cc
@@ -228,8 +228,8 @@ void SsatSolver::computeSsatBdd() {
   bFunc = (DdNode*)Abc_ObjGlobalBdd(Abc_NtkPo(_pNtkCnf, 0));
   Pb_BddResetProb(_dd, bFunc);
   BddComputeSsat_rec(_pNtkCnf, bFunc);
-  _satPb = Cudd_IsComplement(bFunc) ? 1.0 - Cudd_Regular(bFunc)->pMin
-                                    : Cudd_Regular(bFunc)->pMax;
+  _satPb = Cudd_IsComplement(bFunc) ? 1.0 - Cudd_Regular(bFunc)->i.value()->pMin
+                                    : Cudd_Regular(bFunc)->i.value()->pMax;
 }
 
 ////////////////////////////////////////////////////////////////////////
diff --git a/src/ssat/core/ssatBranchBound.cc b/src/ssat/core/ssatBranchBound.cc
index 05e4d1f..527aa07 100644
--- a/src/ssat/core/ssatBranchBound.cc
+++ b/src/ssat/core/ssatBranchBound.cc
@@ -55,7 +55,7 @@ using namespace std;
 
 void SsatSolver::solveBranchBound(Abc_Ntk_t* pNtk) {
   vec<Lit> eLits;
-  double tempValue = 0.0;
+  mpq_class tempValue = 0.0;
 
   _satPb = 0.0;
   _s1 = ntkBuildSolver(pNtk, true);  // assert Po to be false
diff --git a/src/ssat/core/ssatCubeToNtk.cc b/src/ssat/core/ssatCubeToNtk.cc
index d012178..d01dd70 100644
--- a/src/ssat/core/ssatCubeToNtk.cc
+++ b/src/ssat/core/ssatCubeToNtk.cc
@@ -39,7 +39,9 @@ void BddComputeSsat_rec(Abc_Ntk_t*, DdNode*);
 Abc_Obj_t* Ssat_SopAnd2Obj(Abc_Obj_t*, Abc_Obj_t*);
 void Ssat_DumpCubeNtk(Abc_Ntk_t*);
 static Abc_Obj_t* Ssat_SopOr2Obj(Abc_Obj_t*, Abc_Obj_t*);
+extern "C" {
 static void Pb_WriteWMCCla(FILE*, Abc_Ntk_t*);
+}
 
 ////////////////////////////////////////////////////////////////////////
 ///                     FUNCTION DEFINITIONS                         ///
@@ -68,7 +70,7 @@ void SsatSolver::initCubeNetwork(bool fAll) {
   if (!fAll) ntkCreateSelDef(_pNtkCube, _vMapVars);
 }
 
-double SsatSolver::cubeToNetwork(bool sat) {
+mpq_class SsatSolver::cubeToNetwork(bool sat) {
   vec<vec<Lit> >& learntClause = sat ? _satClause : _unsatClause;
   if (!learntClause.size()) return (sat ? _satPb : _unsatPb);
 
@@ -213,6 +215,7 @@ void SsatSolver::ntkWriteWcnf(Abc_Ntk_t* pNtkCube) {
   fclose(out);
 }
 
+extern "C" {
 void Pb_WriteWMCCla(FILE* out, Abc_Ntk_t* pNtk) {
   Abc_Obj_t *pObj, *pFanin0, *pFanin1;
   int i;
@@ -256,6 +259,7 @@ void Pb_WriteWMCCla(FILE* out, Abc_Ntk_t* pNtk) {
   }
   fprintf(out, "%d 0\n", Abc_ObjId(pObj));
 }
+}
 
 /**Function*************************************************************
 
@@ -272,11 +276,11 @@ void Pb_WriteWMCCla(FILE* out, Abc_Ntk_t* pNtk) {
 // FIXME: disable fraig due to complexity
 // SOP to BDD ?? (not via AIG)
 // in Abc_NtkCollapse, always strash ...
-double SsatSolver::ntkBddComputeSp(Abc_Ntk_t* pNtkCube, bool sat) {
+mpq_class SsatSolver::ntkBddComputeSp(Abc_Ntk_t* pNtkCube, bool sat) {
   // Fraig_Params_t Params , * pParams = &Params;
   Abc_Ntk_t *pNtk, *pNtkCopy, *pNtkAig;
   Abc_Obj_t* pObj;
-  double prob;
+  mpq_class prob;
   int i;
 
   pNtkCopy = Abc_NtkDup(pNtkCube);
@@ -286,7 +290,7 @@ double SsatSolver::ntkBddComputeSp(Abc_Ntk_t* pNtkCube, bool sat) {
   pNtk = pNtkAig;
   Abc_NtkForEachPi(pNtk, pObj, i) pObj->dTemp = (float)_quan[_rootVars[0][i]];
 
-  prob = (double)Pb_BddComputeSp(pNtk, (int)sat, 0, 0, 0);
+  prob = Pb_BddComputeSp(pNtk, (int)sat, 0, 0, 0);
   Abc_NtkDelete(pNtkCopy);
   // Abc_NtkDelete( pNtkAig );
   Abc_NtkDelete(pNtk);
@@ -460,7 +464,7 @@ void SsatSolver::erNtkCreatePo(Abc_Ntk_t* pNtkClause) {
   Abc_ObjAssignName(Abc_NtkCreatePo(pNtkClause), "clause_output", "");
 }
 
-double SsatSolver::bddCountWeight(Ssat_Params_t* pParams, const vec<Lit>& eLits,
+mpq_class SsatSolver::bddCountWeight(Ssat_Params_t* pParams, const vec<Lit>& eLits,
                                   const vec<bool>& dropVec) {
   if (!pParams->fIncre2)
     return clauseToNetwork(eLits, dropVec, pParams->fIncre, pParams->fCkt);
@@ -513,14 +517,14 @@ double SsatSolver::bddCountWeight(Ssat_Params_t* pParams, const vec<Lit>& eLits,
       Abc_NtkForEachPi(_pNtkCube, pObj, i) pObj->dTemp =
           (i < _rootVars[1].size()) ? (float)_quan[_rootVars[1][i]] : -1.0;
       // count weight
-      double prob;
+      mpq_class prob;
       if (Cudd_IsConstant(bCnf))
         prob = 1.0;
       else {
         Pb_BddResetProb(_dd, bCnf);
         BddComputeSsat_rec(_pNtkCube, bCnf);
-        prob = Cudd_IsComplement(bCnf) ? 1.0 - Cudd_Regular(bCnf)->pMin
-                                       : Cudd_Regular(bCnf)->pMax;
+        prob = Cudd_IsComplement(bCnf) ? 1.0 - Cudd_Regular(bCnf)->i.value()->pMin
+                                       : Cudd_Regular(bCnf)->i.value()->pMax;
       }
       Cudd_RecursiveDeref(_dd, bCnf);
       return prob;
@@ -528,11 +532,11 @@ double SsatSolver::bddCountWeight(Ssat_Params_t* pParams, const vec<Lit>& eLits,
   }
 }
 
-double SsatSolver::clauseToNetwork(const vec<Lit>& eLits, const vec<bool>& drop,
+mpq_class SsatSolver::clauseToNetwork(const vec<Lit>& eLits, const vec<bool>& drop,
                                    bool fIncre, bool fCkt) {
   Abc_Obj_t* pObj;
   abctime clk = 0;
-  double prob;
+  mpq_class prob;
   int i;
   if (fCkt) {
     Abc_Obj_t* pObjCla;
@@ -559,8 +563,8 @@ double SsatSolver::clauseToNetwork(const vec<Lit>& eLits, const vec<bool>& drop,
     else {
       Pb_BddResetProb(_dd, bCnf);
       BddComputeSsat_rec(_pNtkCube, bCnf);
-      prob = Cudd_IsComplement(bCnf) ? 1.0 - Cudd_Regular(bCnf)->pMin
-                                     : Cudd_Regular(bCnf)->pMax;
+      prob = Cudd_IsComplement(bCnf) ? 1.0 - Cudd_Regular(bCnf)->i.value()->pMin
+                                     : Cudd_Regular(bCnf)->i.value()->pMax;
     }
     return prob;
   }
@@ -691,13 +695,13 @@ DdNode* SsatSolver::erNtkCreateBdd(DdManager* dd, Vec_Ptr_t* vMapVars,
 
 ***********************************************************************/
 
-double SsatSolver::erNtkBddComputeSp(Abc_Ntk_t* pNtkClause, bool fIncre) {
+mpq_class SsatSolver::erNtkBddComputeSp(Abc_Ntk_t* pNtkClause, bool fIncre) {
   Abc_Ntk_t *pNtkCopy, *pNtkAig;
   Abc_Obj_t* pObj;
   Vec_Att_t* pAttMan;
   DdNode* bFunc;
   abctime clk = 0;
-  double prob = 0.0;
+  mpq_class prob = 0.0;
   int i;
 
   pAttMan = NULL;
@@ -712,7 +716,7 @@ double SsatSolver::erNtkBddComputeSp(Abc_Ntk_t* pNtkClause, bool fIncre) {
     Vec_PtrWriteEntry(pNtkAig->vAttrs, VEC_ATTR_GLOBAL_BDD, pAttMan);
     Abc_NtkForEachPi(pNtkAig, pObj, i) {
       pObj->dTemp =
-          (i < _rootVars[1].size()) ? (float)_quan[_rootVars[1][i]] : -1.0;
+          (i < _rootVars[1].size()) ? _quan[_rootVars[1][i]] : -1.0;
       if (!Abc_ObjGlobalBdd(pObj)) {
         bFunc = _dd->vars[i];
         Abc_ObjSetGlobalBdd(pObj, bFunc);
@@ -720,13 +724,13 @@ double SsatSolver::erNtkBddComputeSp(Abc_Ntk_t* pNtkClause, bool fIncre) {
       }
     }
     if (_fTimer) clk = Abc_Clock();
-    prob = (double)Ssat_BddComputeRESp(pNtkAig, _dd, 0, _rootVars[1].size(), 1);
+    prob = Ssat_BddComputeRESp(pNtkAig, _dd, 0, _rootVars[1].size(), 1);
     if (_fTimer) timer.timeBd += Abc_Clock() - clk;
   } else {
     Abc_NtkForEachPi(pNtkAig, pObj, i) pObj->dTemp =
         (i < _rootVars[1].size()) ? (float)_quan[_rootVars[1][i]] : -1.0;
     if (_fTimer) clk = Abc_Clock();
-    prob = (double)Pb_BddComputeRESp(pNtkAig, 0, _rootVars[1].size(), 1, 0);
+    prob = Pb_BddComputeRESp(pNtkAig, 0, _rootVars[1].size(), 1, 0);
     if (_fTimer) timer.timeBd += Abc_Clock() - clk;
   }
   if (_fTimer) clk = Abc_Clock();
diff --git a/src/ssat/core/ssatERSolve.cc b/src/ssat/core/ssatERSolve.cc
index b79f729..3a847c2 100644
--- a/src/ssat/core/ssatERSolve.cc
+++ b/src/ssat/core/ssatERSolve.cc
@@ -79,7 +79,7 @@ void SsatSolver::erSolve2SSAT(Ssat_Params_t* pParams) {
   vec<Lit> eLits(_rootVars[0].size()), sBkCla;
   vec<bool> dropVec(_rootVars[0].size(), false);
   int lenBeforeDrop = 0;
-  double subvalue;
+  mpq_class subvalue;
   bool sat;
   abctime clk = 0, clk1 = Abc_Clock();
   _erModel.capacity(_rootVars[0].size());
@@ -149,7 +149,7 @@ void SsatSolver::erSolve2SSAT(Ssat_Params_t* pParams) {
       if (subvalue >= _satPb) {  // update current solution
         if (_fVerbose) {
           if (subvalue > _satPb) {
-            printf("  > Found a better solution , value = %f\n\t", subvalue);
+            std::cout << "  > Found a better solution , value = " << subvalue << "\n\t";
             dumpCla(eLits);
             Abc_PrintTime(1, "  > Time consumed", Abc_Clock() - clk1);
             fflush(stdout);
@@ -385,7 +385,7 @@ bool SsatSolver::subsume(const Clause& c1, const Clause& c2) const {
 void SsatSolver::discardLit(Ssat_Params_t* pParams, vec<Lit>& sBkCla) {
   if (sBkCla.size() == 0) return;
   abctime clk = 0;
-  double subvalue = 0.0;
+  mpq_class subvalue = 0.0;
   vec<Lit> eLits;
   convertClaCube(sBkCla, eLits);
   vec<bool> dropVec(eLits.size(), false);
@@ -452,7 +452,7 @@ void convertClaCube(const vec<Lit>& cla, vec<Lit>& cube) {
 void SsatSolver::discardAllLit(Ssat_Params_t* pParams, vec<Lit>& sBkCla) {
   if (sBkCla.size() == 0) return;
   abctime clk = 0;
-  double subvalue = 0.0;
+  mpq_class subvalue = 0.0;
   vec<Lit> eLits;
   convertClaCube(sBkCla, eLits);
   vec<bool> dropVec(eLits.size(), false);
@@ -515,14 +515,14 @@ void SsatSolver::removeDupLit(vec<Lit>& c) const {
 
 ***********************************************************************/
 
-double SsatSolver::erSolveWMC(Ssat_Params_t* pParams, const vec<Lit>& eLits,
+mpq_class SsatSolver::erSolveWMC(Ssat_Params_t* pParams, const vec<Lit>& eLits,
                               const vec<bool>& dropVec, int dropIndex) {
-  double satisfyProb = pParams->fBdd ? bddCountWeight(pParams, eLits, dropVec)
+  mpq_class satisfyProb = pParams->fBdd ? bddCountWeight(pParams, eLits, dropVec)
                                      : countModels(eLits, dropIndex);
   return _unitClauseMultiplier * satisfyProb;
 }
 
-double SsatSolver::countModels(const vec<Lit>& sBkCla, int dropIndex) {
+mpq_class SsatSolver::countModels(const vec<Lit>& sBkCla, int dropIndex) {
   // return _satPb;
   FILE* file;
   int length = 1024;
diff --git a/src/ssat/core/ssatModelCount.cc b/src/ssat/core/ssatModelCount.cc
index 75b4ed3..022b178 100644
--- a/src/ssat/core/ssatModelCount.cc
+++ b/src/ssat/core/ssatModelCount.cc
@@ -53,8 +53,8 @@ using namespace std;
 
 ***********************************************************************/
 
-double SsatSolver::allSatModelCount(Solver* s, const vec<Lit>& assump,
-                                    double curVal) {
+mpq_class SsatSolver::allSatModelCount(Solver* s, const vec<Lit>& assump,
+                                    mpq_class curVal) {
 #ifdef DEBUG
   printf("  > current exist assignment:\n");
   dumpCla(assump);
@@ -66,7 +66,7 @@ double SsatSolver::allSatModelCount(Solver* s, const vec<Lit>& assump,
   _control.push(s->newVar());
   for (int i = 0; i < _control.size(); ++i) eLits.push(mkLit(_control[i]));
   eLits.last() = ~eLits.last();
-  double count = 0.0, prob;
+  mpq_class count = 0.0, prob;
 
   while (s->solve(eLits)) {
 #ifdef DEBUG
diff --git a/src/ssat/core/ssat_test.cc b/src/ssat/core/ssat_test.cc
index 85695ae..df68df0 100644
--- a/src/ssat/core/ssat_test.cc
+++ b/src/ssat/core/ssat_test.cc
@@ -25,7 +25,7 @@ extern void initParams(Ssat_Params_t*);
 
 static void runTestWithParamsAndVerdict(const char* pTestCase,
                                         Ssat_Params_t* pParams,
-                                        const double pVerdict) {
+                                        const mpq_class pVerdict) {
   abctime clk = Abc_Clock();
   Abc_Print(-2, "[INFO] Input sdimacs file: %s\n", pTestCase);
   gzFile in = gzopen(pTestCase, "rb");
@@ -35,10 +35,10 @@ static void runTestWithParamsAndVerdict(const char* pTestCase,
   pSsat->solveSsat(pParams);
   pSsat->reportSolvingResults();
   Abc_PrintTime(1, "  > Time", Abc_Clock() - clk);
-  double answer = pSsat->exactSatProb();
+  mpq_class answer = pSsat->exactSatProb();
   delete pSsat;
   printf("-------------------------------------------\n");
-  REQUIRE(answer == Approx(pVerdict));
+  REQUIRE(answer.get_d() == Approx(pVerdict.get_d()));
 }
 
 ////////////////////////////////////////////////////////////////////////
@@ -49,7 +49,7 @@ TEST_CASE("toilet_1", "[planning]") {
   const char* testCase =
       "test/test-cases/ssatER/planning/ToiletA/sdimacs/"
       "toilet_a_08_01.2.sdimacs";
-  double verdict = 7.812500e-03;
+  mpq_class verdict = 7.812500e-03;
   Ssat_Params_t Params, *pParams = &Params;
   initParams(pParams);
   pParams->fPart = false;
@@ -60,7 +60,7 @@ TEST_CASE("toilet_2", "[planning]") {
   const char* testCase =
       "test/test-cases/ssatER/planning/ToiletA/sdimacs/"
       "toilet_a_08_01.4.sdimacs";
-  double verdict = 1.562500e-02;
+  mpq_class verdict = 1.562500e-02;
   Ssat_Params_t Params, *pParams = &Params;
   initParams(pParams);
   runTestWithParamsAndVerdict(testCase, pParams, verdict);
@@ -70,7 +70,7 @@ TEST_CASE("toilet_3", "[planning]") {
   const char* testCase =
       "test/test-cases/ssatER/planning/ToiletA/sdimacs/"
       "toilet_a_10_01.2.sdimacs";
-  double verdict = 1.953125e-03;
+  mpq_class verdict = 1.953125e-03;
   Ssat_Params_t Params, *pParams = &Params;
   initParams(pParams);
   pParams->fPart = false;
@@ -81,7 +81,7 @@ TEST_CASE("toilet_3", "[planning]") {
 TEST_CASE("sand-castle-10", "[planning]") {
   const char* testCase =
       "test/test-cases/ssatER/planning/sand-castle/sdimacs/SC-10.sdimacs";
-  double verdict = 9.668871e-01;
+  mpq_class verdict = 9.668871e-01;
   Ssat_Params_t Params, *pParams = &Params;
   initParams(pParams);
   runTestWithParamsAndVerdict(testCase, pParams, verdict);
@@ -90,7 +90,7 @@ TEST_CASE("sand-castle-10", "[planning]") {
 TEST_CASE("sand-castle-10-gsp", "[planning]") {
   const char* testCase =
       "test/test-cases/ssatER/planning/sand-castle/sdimacs/SC-10.sdimacs";
-  double verdict = 9.668871e-01;
+  mpq_class verdict = 9.668871e-01;
   Ssat_Params_t Params, *pParams = &Params;
   initParams(pParams);
   pParams->fGreedy = false;
@@ -103,7 +103,7 @@ TEST_CASE("conformant-cube", "[planning]") {
   const char* testCase =
       "test/test-cases/ssatER/planning/conformant/sdimacs/"
       "cube_c3_ser--opt-6_.sdimacs";
-  double verdict = 1;
+  mpq_class verdict = 1;
   Ssat_Params_t Params, *pParams = &Params;
   initParams(pParams);
   runTestWithParamsAndVerdict(testCase, pParams, verdict);
@@ -113,7 +113,7 @@ TEST_CASE("conformant-cube-gsp", "[planning]") {
   const char* testCase =
       "test/test-cases/ssatER/planning/conformant/sdimacs/"
       "cube_c3_ser--opt-6_.sdimacs";
-  double verdict = 1;
+  mpq_class verdict = 1;
   Ssat_Params_t Params, *pParams = &Params;
   initParams(pParams);
   pParams->fGreedy = false;
@@ -125,7 +125,7 @@ TEST_CASE("conformant-cube-gsp", "[planning]") {
 TEST_CASE("QIF-backdoor", "[planning]") {
   const char* testCase =
       "test/test-cases/ssatER/MaxCount/sdimacs/QIF-backdoor-32-24.sdimacs";
-  double verdict = 1;
+  mpq_class verdict = 1;
   Ssat_Params_t Params, *pParams = &Params;
   initParams(pParams);
   runTestWithParamsAndVerdict(testCase, pParams, verdict);
@@ -134,7 +134,7 @@ TEST_CASE("QIF-backdoor", "[planning]") {
 TEST_CASE("QIF-backdoor-gsp", "[planning]") {
   const char* testCase =
       "test/test-cases/ssatER/MaxCount/sdimacs/QIF-backdoor-32-24.sdimacs";
-  double verdict = 1;
+  mpq_class verdict = 1;
   Ssat_Params_t Params, *pParams = &Params;
   initParams(pParams);
   pParams->fGreedy = false;
@@ -145,7 +145,7 @@ TEST_CASE("QIF-backdoor-gsp", "[planning]") {
 
 TEST_CASE("MPEC-c499", "[planning]") {
   const char* testCase = "test/test-cases/ssatER/MPEC/sdimacs/c499-er.sdimacs";
-  double verdict = 2.343750e-01;
+  mpq_class verdict = 2.343750e-01;
   Ssat_Params_t Params, *pParams = &Params;
   initParams(pParams);
   runTestWithParamsAndVerdict(testCase, pParams, verdict);
@@ -153,7 +153,7 @@ TEST_CASE("MPEC-c499", "[planning]") {
 
 TEST_CASE("MPEC-c499-gsp", "[planning]") {
   const char* testCase = "test/test-cases/ssatER/MPEC/sdimacs/c499-er.sdimacs";
-  double verdict = 2.343750e-01;
+  mpq_class verdict = 2.343750e-01;
   Ssat_Params_t Params, *pParams = &Params;
   initParams(pParams);
   pParams->fGreedy = false;
@@ -165,7 +165,7 @@ TEST_CASE("MPEC-c499-gsp", "[planning]") {
 TEST_CASE("strategic-company-20.4", "[planning]") {
   const char* testCase =
       "test/test-cases/ssatRE/stracomp/sdimacs/x20.4.sdimacs";
-  double verdict = 9.999971e-01;
+  mpq_class verdict = 9.999971e-01;
   Ssat_Params_t Params, *pParams = &Params;
   initParams(pParams);
   runTestWithParamsAndVerdict(testCase, pParams, verdict);
@@ -173,7 +173,7 @@ TEST_CASE("strategic-company-20.4", "[planning]") {
 
 TEST_CASE("PEC-c3540", "[planning]") {
   const char* testCase = "test/test-cases/ssatRE/PEC/sdimacs/c3540_re.sdimacs";
-  double verdict = 3.417969e-03;
+  mpq_class verdict = 3.417969e-03;
   Ssat_Params_t Params, *pParams = &Params;
   initParams(pParams);
   runTestWithParamsAndVerdict(testCase, pParams, verdict);
@@ -182,7 +182,7 @@ TEST_CASE("PEC-c3540", "[planning]") {
 TEST_CASE("random-RE", "[planning]") {
   const char* testCase =
       "test/test-cases/ssatRE/random/3CNF/sdimacs/rand-3-40-120-20.165.sdimacs";
-  double verdict = 1.207352e-03;
+  mpq_class verdict = 1.207352e-03;
   Ssat_Params_t Params, *pParams = &Params;
   initParams(pParams);
   runTestWithParamsAndVerdict(testCase, pParams, verdict);
